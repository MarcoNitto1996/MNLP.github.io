import*as i from'valibot';import b from'chalk';import {Octokit}from'octokit';var C=i.object({name:i.string(),category:i.string(),localDependencies:i.array(i.string()),dependencies:i.array(i.string()),devDependencies:i.array(i.string()),tests:i.boolean(),list:i.optional(i.boolean(),true),directory:i.string(),subdirectory:i.boolean(),files:i.array(i.string()),_imports_:i.record(i.string(),i.string())}),x=i.object({name:i.string(),blocks:i.array(C)}),M=i.object({authors:i.optional(i.array(i.string())),bugs:i.optional(i.string()),description:i.optional(i.string()),homepage:i.optional(i.string()),repository:i.optional(i.string()),tags:i.optional(i.array(i.string()))}),j=i.object({meta:i.optional(M),categories:i.array(x)});var U="jsrepo-manifest.json",X="jsrepo.json";var Y="main",m={name:"azure",matches:r=>r.toLowerCase().startsWith("azure"),parse:(r,e)=>{let t=P(r,e);return {url:t.url,specifier:t.specifier}},baseUrl:r=>{let{owner:e,repoName:t}=P(r,{fullyQualified:false});return `https://dev.azure.com/${e}/_git/${t}`},state:async r=>{let{url:e,owner:t,project:o,repoName:a,ref:s,refs:n}=P(r,{fullyQualified:false});return {owner:t,repoName:a,ref:s,refs:n,project:o,url:e,provider:m}},resolveRaw:async(r,e)=>{if(r.provider.name!==m.name)throw new Error(`You passed the incorrect state object (${r.provider.name}) to the ${m.name} provider.`);let{owner:t,repoName:o,project:a,ref:s,refs:n}=r,p=n==="tags"?"tag":"branch";return new URL(`https://dev.azure.com/${t}/${a}/_apis/git/repositories/${o}/items?path=${e}&api-version=7.2-preview.1&versionDescriptor.version=${s}&versionDescriptor.versionType=${p}`)},authHeader:r=>["Authorization",`Bearer ${r}`],formatFetchError:(r,e)=>`There was an error fetching \`${b.bold(e)}\` from ${b.bold(r.url)}.

${b.bold("This may be for one of the following reasons:")}
1. Either \`${b.bold(e)}\` or the containing repository doesn't exist
2. Your repository path is incorrect (wrong branch, wrong tag)
3. You are using an expired access token or a token that doesn't have access to this repository
`},P=(r,{fullyQualified:e})=>{let t=r.replaceAll(/(azure\/)/g,""),[o,a,s,...n]=t.split("/"),p;e&&(p=n.slice(n.length-2).join("/"),n=n.slice(0,n.length-2));let c=Y,l="heads";return ["tags","heads"].includes(n[0])&&(l=n[0],n[1]&&n[1]!==""&&(c=n[1])),{url:`azure/${o}/${a}/${s}${c?`/${l}/${c}`:""}`,owner:o,repoName:s,project:a,ref:c,refs:l,specifier:p}};var g=(r,e)=>{for(let t of e)if(r.startsWith(t))return  true;return  false};var L="master",d={name:"bitbucket",matches:r=>g(r.toLowerCase(),["bitbucket","https://bitbucket.org"]),parse:(r,e)=>{let t=T(r,e);return {url:t.url,specifier:t.specifier}},baseUrl:r=>{let{owner:e,repoName:t}=T(r,{fullyQualified:false});return `https://bitbucket.org/${e}/${t}`},state:async(r,{token:e,fetch:t=fetch}={})=>{let{url:o,owner:a,repoName:s,ref:n}=T(r,{fullyQualified:false});if(n===undefined)try{let p=new Headers;if(e!==void 0){let[l,S]=d.authHeader(e);p.append(l,S);}let c=await t(`https://api.bitbucket.org/2.0/repositories/${a}/${s}`,{headers:p});c.ok?n=(await c.json()).mainbranch.name:n=L;}catch{n=L;}return {owner:a,ref:n,repoName:s,url:o,provider:d}},resolveRaw:async(r,e)=>{if(r.provider.name!==d.name)throw new Error(`You passed the incorrect state object (${r.provider.name}) to the ${d.name} provider.`);let{owner:t,repoName:o,ref:a}=r;return new URL(e,`https://api.bitbucket.org/2.0/repositories/${t}/${o}/src/${a}/`)},authHeader:r=>["Authorization",`Bearer ${r}`],formatFetchError:(r,e)=>`There was an error fetching \`${b.bold(e)}\` from ${b.bold(r.url)}.

${b.bold("This may be for one of the following reasons:")}
1. Either \`${b.bold(e)}\` or the containing repository doesn't exist
2. Your repository path is incorrect (wrong branch, wrong tag)
3. You are using an expired access token or a token that doesn't have access to this repository
`},T=(r,{fullyQualified:e=false})=>{let t=r.replaceAll(/(https:\/\/bitbucket.org\/)|(bitbucket\/)/g,""),[o,a,...s]=t.split("/"),n;e&&(n=s.slice(s.length-2).join("/"),s=s.slice(0,s.length-2));let p;return s[0]==="src"&&(p=s[1]),{url:`bitbucket/${o}/${a}${p?`/src/${p}`:""}`,specifier:n,owner:o,repoName:a,ref:p}};var _="main",v={name:"github",matches:r=>g(r.toLowerCase(),["github","https://github.com"]),parse:(r,e)=>{let t=k(r,e);return {url:t.url,specifier:t.specifier}},baseUrl:r=>{let{owner:e,repoName:t}=k(r,{fullyQualified:false});return `https://github.com/${e}/${t}`},state:async(r,{token:e}={})=>{let{url:t,owner:o,repoName:a,ref:s}=k(r,{fullyQualified:false}),n=new Octokit({auth:e}),p="heads";if(s===undefined)try{let{data:c}=await n.rest.repos.get({owner:o,repo:a});s=c.default_branch;}catch{s=_;}else if(s!==_)try{let{data:c}=await n.rest.git.listMatchingRefs({owner:o,repo:a,ref:"tags"});c.some(l=>l.ref===`refs/tags/${s}`)&&(p="tags");}catch{p="heads";}return {owner:o,refs:p,ref:s,repoName:a,url:t,provider:v}},resolveRaw:async(r,e)=>{if(r.provider.name!==v.name)throw new Error(`You passed the incorrect state object (${r.provider.name}) to the ${v.name} provider.`);let{owner:t,repoName:o,refs:a,ref:s}=r;return new URL(e,`https://raw.githubusercontent.com/${t}/${o}/refs/${a}/${s}/`)},authHeader:r=>["Authorization",`token ${r}`],formatFetchError:(r,e)=>`There was an error fetching \`${b.bold(e)}\` from ${b.bold(r.url)}.

${b.bold("This may be for one of the following reasons:")}
1. Either \`${b.bold(e)}\` or the containing repository doesn't exist
2. Your repository path is incorrect (wrong branch, wrong tag)
3. You are using an expired access token or a token that doesn't have access to this repository
`},k=(r,{fullyQualified:e=false})=>{let t=r.replaceAll(/(https:\/\/github.com\/)|(github\/)/g,""),[o,a,...s]=t.split("/"),n;e&&(n=s.slice(s.length-2).join("/"),s=s.slice(0,s.length-2));let p;return s.length>0&&s[0]==="tree"&&(p=s[1]),{url:`github/${o}/${a}${p?`/tree/${p}`:""}`,specifier:n,owner:o,repoName:a,ref:p}};var F="main",h={name:"gitlab",matches:r=>g(r.toLowerCase(),["gitlab","https://gitlab.com"]),parse:(r,e)=>{let t=O(r,e);return {url:t.url,specifier:t.specifier}},baseUrl:r=>{let{owner:e,repoName:t}=O(r,{fullyQualified:false});return `https://gitlab.com/${e}/${t}`},state:async(r,{token:e,fetch:t=fetch}={})=>{let{url:o,owner:a,repoName:s,ref:n}=O(r,{fullyQualified:false});if(n===undefined)try{let p=new Headers;if(e!==void 0){let[l,S]=h.authHeader(e);p.append(l,S);}let c=await t(`https://gitlab.com/api/v4/projects/${encodeURIComponent(`${a}/${s}`)}`,{headers:p});c.ok?n=(await c.json()).default_branch:n=F;}catch{n=F;}return {owner:a,repoName:s,ref:n,url:o,provider:h}},resolveRaw:async(r,e)=>{if(r.provider.name!==h.name)throw new Error(`You passed the incorrect state object (${r.provider.name}) to the ${h.name} provider.`);let{owner:t,repoName:o,ref:a}=r;return new URL(`${encodeURIComponent(e)}/raw?ref=${a}`,`https://gitlab.com/api/v4/projects/${encodeURIComponent(`${t}/${o}`)}/repository/files/`)},authHeader:r=>["PRIVATE-TOKEN",r],formatFetchError:(r,e)=>`There was an error fetching \`${b.bold(e)}\` from ${b.bold(r.url)}.

${b.bold("This may be for one of the following reasons:")}
1. Either \`${b.bold(e)}\` or the containing repository doesn't exist
2. Your repository path is incorrect (wrong branch, wrong tag)
3. You are using an expired access token or a token that doesn't have access to this repository
`},O=(r,{fullyQualified:e})=>{let t=r.replaceAll(/(https:\/\/gitlab.com\/)|(gitlab\/)/g,""),[o,a,...s]=t.split("/"),n;e&&(n=s.slice(s.length-2).join("/"),s=s.slice(0,s.length-2));let p;if(s[0]==="-"&&s[1]==="tree")if(s[2].includes("?")){let[c]=s[2].split("?");p=c;}else p=s[2];return {url:`gitlab/${o}/${a}${p?`/-/tree/${p}`:""}`,owner:o,repoName:a,ref:p,specifier:n}};var H=(...r)=>r.map(e=>Q(e)).filter(Boolean).join("/"),Q=r=>{let e=D(r);return G(e)};var D=r=>{let e=r;return e.startsWith("/")&&(e=e.slice(1)),e};var G=r=>{let e=r;return e.endsWith("/")&&(e=e.slice(0,e.length-1)),e},z=r=>{let e=r;return e.endsWith("/")||(e=`${e}/`),e};var y={name:"http",matches:r=>r.toLowerCase().startsWith("http"),parse:(r,e)=>{let t=N(r,e);return {url:t.url,specifier:t.specifier}},baseUrl:r=>{let{url:e}=N(r,{fullyQualified:false});return new URL(e).origin},state:async r=>{let{url:e}=N(r,{fullyQualified:false});return {url:e,provider:y}},resolveRaw:async(r,e)=>{if(r.provider.name!==y.name)throw new Error(`You passed the incorrect state object (${r.provider.name}) to the ${y.name} provider.`);return new URL(e,r.url)},formatFetchError:(r,e,t)=>`There was an error fetching ${b.bold(new URL(e,r.url).toString())}
	
${b.bold(t)}`},N=(r,{fullyQualified:e})=>{let t=new URL(r),o=t.pathname.split("/"),a;return e&&(a=o.slice(o.length-2).join("/"),o=o.slice(0,o.length-2)),{url:z(H(t.origin,...o)),specifier:a}};var A=class{_result;constructor(e){this._result=e;}match(e,t){return this._result.ok?e(this._result.val):t(this._result.err)}map(e){return this.match(t=>f(e(t)),t=>u(t))}mapOr(e,t){return this.match(o=>t(o),o=>e)}mapOrElse(e,t){return this.match(o=>t(o),o=>e(o))}mapErr(e){return this.match(t=>f(t),t=>u(e(t)))}mapErrOr(e,t){return this.match(o=>e,o=>t(o))}mapErrOrElse(e,t){return this.match(o=>e(o),o=>t(o))}isOk(){return this.match(()=>true,()=>false)}isErr(){return this.match(()=>false,()=>true)}unwrap(){return this.match(e=>e,()=>{throw new Error("Attempted to call `.unwrap()` on a non `Ok` value.")})}unwrapErr(){return this.match(()=>{throw new Error("Attempted to call `.unwrapErr()` on a non `Err` value.")},e=>e)}unwrapOr(e){return this.match(t=>t,t=>e)}unwrapErrOr(e){return this.match(()=>e,t=>t)}unwrapOrElse(e){return this.match(t=>t,t=>e(t))}unwrapErrOrElse(e){return this.match(t=>e(t),t=>t)}expect(e){return this.match(t=>t,()=>{throw new Error(e)})}expectErr(e){return this.match(()=>{throw new Error(e)},t=>t)}},f=r=>new A({ok:true,val:r}),u=r=>new A({ok:false,err:r});var I=r=>{let e;try{e=JSON.parse(r);}catch(o){return u(`Error parsing manifest json ${o}`)}if(Array.isArray(e)){let o=i.safeParse(i.array(x),e);return o.success?f({categories:o.output}):u(`Error parsing categories (array-based config) ${o.issues.join(" ")}`)}let t=i.safeParse(j,e);return t.success?f(t.output):u(`Error parsing manifest ${t.issues.join(" ")}`)};var K=[v,h,d,m,y],Pe=r=>K.find(t=>t.matches(r)),V=async(r,e,{verbose:t,fetch:o=fetch,token:a}={})=>{let s=await r.provider.resolveRaw(r,e);t?.(`Trying to fetch from ${s}`);try{let n=new Headers;if(a!==void 0&&r.provider.authHeader){let[c,l]=r.provider.authHeader(a);n.append(c,l);}let p=await o(s,{headers:n});return t?.(`Got a response from ${s} ${p.status} ${p.statusText}`),p.ok?f(await p.text()):u(r.provider.formatFetchError(r,e,`${p.status} ${p.statusText}`))}catch(n){return u(r.provider.formatFetchError(r,e,n))}},Te=async(r,{fetch:e=fetch,...t}={})=>{let o=await V(r,U,{fetch:e,...t});return o.isErr()?u(o.unwrapErr()):I(o.unwrap())};export{f as a,u as b,H as c,C as d,x as e,M as f,j as g,U as h,X as i,I as j,m as k,d as l,v as m,h as n,y as o,K as p,Pe as q,V as r,Te as s};//# sourceMappingURL=chunk-QDKEPRMN.js.map
//# sourceMappingURL=chunk-QDKEPRMN.js.map