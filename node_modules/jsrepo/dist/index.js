#!/usr/bin/env node
import {f,q,c,p,o,h,j,b,a,s,r}from'./chunk-QDKEPRMN.js';import Oe from'node:fs';import {fileURLToPath}from'node:url';import {Command,program,Option,Argument}from'commander';import H from'pathe';import {outro,spinner,confirm,isCancel,cancel,multiselect,text,select,log,password,intro}from'@clack/prompts';import P from'chalk';import {resolveCommand}from'package-manager-detector/commands';import {detect}from'package-manager-detector/detect';import*as k from'valibot';import {getTsconfig,createPathsMatcher}from'get-tsconfig';import Xt from'node-fetch';import Wo from'conf';import {builtinModules}from'node:module';import {Biome,Distribution}from'@biomejs/js-api';import {walk}from'estree-walker';import*as Kr from'parse5';import*as Ne from'prettier';import*as qr from'svelte/compiler';import {Project}from'ts-morph';import Xo from'validate-npm-package-name';import*as Lt from'vue/compiler-sfc';import Ko from'node:os';import zo from'ansi-regex';import Mr from'semver';import {execa}from'execa';import {detect as detect$1,resolveCommand as resolveCommand$1,detectSync}from'package-manager-detector';import bn from'escape-string-regexp';import po from'boxen';import Yn from'ignore';import {diffLines,diffChars}from'diff';import Os from'@anthropic-ai/sdk';import Fs from'ollama';import Bs from'openai';var B=P.gray("\u2502"),qt=P.gray("\u2500"),Er=P.gray("\u2510"),Dr=P.gray("\u2518"),Ut=P.gray("\u251C");P.gray("\u250C");P.gray("\u2514");var xe=P.bgRgb(245,149,66).black(" WARN "),at=P.bgBlueBright.white(" INFO "),It=P.bgRedBright.white(" ERROR "),fe=P.hex("#f7df1e")("jsrepo");var Or=(e,t)=>{let r=[];for(let[o,n]of e)r.push(t(o,n));return r};var To=/^(@[^\/]+\/[^@\/]+)(?:@([^\/]+))?(\/.*)?$/,Ao=/^([^@\/]+)(?:@([^\/]+))?(\/.*)?$/,Ye=e=>{let t=To.exec(e)||Ao.exec(e);return t?a({name:t[1]||"",version:t[2]||"latest",path:t[3]||""}):b(`invalid package name: ${e}`)};var Nr=k.union([k.literal("off"),k.literal("warn"),k.literal("error")]),Fo={"no-unpinned-dependency":{description:"Require all dependencies to have a pinned version.",check:e=>{let t=[];for(let r of [...e.dependencies,...e.devDependencies])r.includes("@")||t.push(`Couldn't find a version to use for ${P.bold(r)}`);return t.length>0?t:undefined}},"require-local-dependency-exists":{description:"Require all local dependencies to exist.",check:(e,{manifest:t})=>{let r=[];for(let o of e.localDependencies){let[n,s]=o.split("/"),i=t.categories.find(l=>l.name.trim()===n.trim()),a=`${P.bold(`${e.category}/${e.name}`)} depends on local dependency ${P.bold(o)} which doesn't exist`;if(!i){r.push(a);continue}i.blocks.find(l=>l.name===s)===undefined&&r.push(a);}return r.length>0?r:undefined}},"no-category-index-file-dependency":{description:"Disallow depending on the index file of a category.",check:(e,{manifest:t})=>{let r=[];for(let o of e.localDependencies){let[n,s]=o.split("/");if(s!=="index")continue;let i=t.categories.find(l=>l.name===n);!i||!i.blocks.find(l=>l.name===s)||r.push(`${P.bold(`${e.category}/${e.name}`)} depends on ${P.bold(`${n}/${s}`)}`);}return r.length>0?r:undefined}},"max-local-dependencies":{description:"Enforces a limit on the amount of local dependencies a block can have.",check:(e,{options:t})=>{let r=[],o;return typeof t[0]!="number"?o=5:o=t[0],e.localDependencies.length>o&&r.push(`${P.bold(`${e.category}/${e.name}`)} has too many local dependencies (${P.bold(e.localDependencies.length)}) limit (${P.bold(o)})`),r.length>0?r:undefined}},"no-circular-dependency":{description:"Disallow circular dependencies.",check:(e,{manifest:t})=>{let r=[],o=`${e.category}/${e.name}`,n=Et(o,e,t.categories);return n&&r.push(`There is a circular dependency in ${P.bold(o)}: ${P.bold(n.join(" -> "))}`),r.length>0?r:undefined}},"no-unused-block":{description:"Disallow unused blocks. (Not listed and not a dependency of another block)",check:(e,{manifest:t})=>{if(e.list)return;let r=`${e.category}/${e.name}`,o=t.categories.flatMap(n=>n.blocks).filter(n=>n.list);for(let n of o)if(Et(r,n,t.categories))return;return [`${P.bold(r)} is unused and will be ${P.bold.red("removed")}`]}},"no-framework-dependency":{description:"Disallow frameworks (Svelte, Vue, React) as dependencies.",check:e=>{let t=[],r=new Set(["svelte","@sveltejs/kit","vue","nuxt","react","react-dom","next","@remix-run/react","@angular/core","@angular/common","@angular/forms","@angular/platform-browser","@angular/platform-browser-dynamic","@angular/router","@builder.io/qwik","astro","solid-js"]),o=[...e.devDependencies,...e.dependencies].map(n=>Ye(n).unwrap().name).filter(n=>r.has(n));if(o.length>0)for(let n of o)t.push(`${P.bold(`${e.category}/${e.name}`)} depends on ${P.bold(n)} causing it to be installed when added`);return t.length>0?t:undefined}}},Bo=k.union([k.literal("no-category-index-file-dependency"),k.literal("no-unpinned-dependency"),k.literal("require-local-dependency-exists"),k.literal("max-local-dependencies"),k.literal("no-circular-dependency"),k.literal("no-unused-block"),k.literal("no-framework-dependency")]),Tr=k.record(Bo,k.union([Nr,k.tupleWithRest([Nr,k.union([k.string(),k.number()])],k.union([k.string(),k.number()]))])),Ht={"no-category-index-file-dependency":"warn","no-unpinned-dependency":"warn","require-local-dependency-exists":"error","max-local-dependencies":["warn",10],"no-circular-dependency":"error","no-unused-block":"warn","no-framework-dependency":"warn"},Ar=(e,t,r=Ht)=>{let o=[],n=[];for(let s of e.categories)for(let i of s.blocks)for(let[a,l]of Object.entries(Fo)){let f=r[a],m,u=[];if(Array.isArray(f)?(m=f[0],u.push(...f.slice(1))):m=f,m==="off")continue;let d=l.check(i,{manifest:e,options:u,config:t});if(d){if(m==="error"){n.push(...d.map(c=>`${B}  ${It} ${P.red(c)} ${P.gray(a)}`));continue}o.push(...d.map(c=>`${B}  ${xe} ${c} ${P.gray(a)}`));}}return {warnings:o,errors:n}},Et=(e,t,r,o=[])=>{let n=[...o,`${t.category}/${t.name}`];for(let s of t.localDependencies){if(s===e)return n;if(o.includes(s))return;let[i,a]=s.split("/"),l=r.find(m=>m.name===i)?.blocks.find(m=>m.name===a);if(!l)continue;let f=Et(e,l,r,n);if(f)return [...f,e]}},Fr=(e,t)=>{for(let r of t)for(let o of r.blocks){if(!o.list)continue;if(Et(e,o,t))return  true}return  false};var Qe="jsrepo.json",Ge="jsrepo-build-config.json",Yt=k.union([k.literal("prettier"),k.literal("biome")]),_o=k.objectWithRest({"*":k.string()},k.string()),Qt=k.object({$schema:k.string(),repos:k.optional(k.array(k.string()),[]),includeTests:k.boolean(),paths:_o,watermark:k.optional(k.boolean(),true),formatter:k.optional(Yt)}),Ee=e=>{if(!Oe.existsSync(H.join(e,Qe)))return b("Could not find your configuration file! Please run `init`.");let t=k.safeParse(Qt,JSON.parse(Oe.readFileSync(H.join(e,Qe)).toString()));return t.success?a(t.output):b(`There was an error reading your \`${Qe}\` file!`)},Mo=k.object({$schema:k.string(),meta:k.optional(f),dirs:k.array(k.string()),outputDir:k.optional(k.string()),includeBlocks:k.optional(k.array(k.string()),[]),includeCategories:k.optional(k.array(k.string()),[]),excludeBlocks:k.optional(k.array(k.string()),[]),excludeCategories:k.optional(k.array(k.string()),[]),doNotListBlocks:k.optional(k.array(k.string()),[]),doNotListCategories:k.optional(k.array(k.string()),[]),listBlocks:k.optional(k.array(k.string()),[]),listCategories:k.optional(k.array(k.string()),[]),excludeDeps:k.optional(k.array(k.string()),[]),allowSubdirectories:k.optional(k.boolean()),preview:k.optional(k.boolean()),rules:k.optional(Tr)}),Ot=e=>{if(!Oe.existsSync(H.join(e,Ge)))return a(null);let t=k.safeParse(Mo,JSON.parse(Oe.readFileSync(H.join(e,Ge)).toString()));return t.success?a(t.output):b(`There was an error reading your \`${Ge}\` file!`)},De=(e,t)=>{let r=getTsconfig(t,"tsconfig.json"),o=null;r||(r=getTsconfig(t,"jsconfig.json")),r&&(o=createPathsMatcher(r));let n;if(e["*"].startsWith("."))n={"*":H.relative(t,H.join(H.resolve(t),e["*"]))};else {if(o===null)return b("Cannot resolve aliases because we couldn't find a tsconfig!");n={"*":Lr(e["*"],o,t)};}for(let[s,i]of Object.entries(e))if(s!=="*"){if(i.startsWith(".")){n[s]=H.relative(t,H.join(H.resolve(t),i));continue}if(o===null)return b("Cannot resolve aliases because we couldn't find a tsconfig!");n[s]=Lr(i,o,t);}return a(n)},Lr=(e,t,r)=>{let o=t(e);return H.relative(r,o[0])},ze=(e,t,r)=>{let o;return t[e.category]!==undefined?o=H.join(r,t[e.category]):o=H.join(r,t["*"],e.category),o};var he=()=>new Wo({projectName:"jsrepo"});var Ke=async(e,t,{verbose:r$1}={})=>await r(e,t,{verbose:r$1,fetch:Xt,token:er(e.provider)}),Zt=async(e,{verbose:t}={})=>await s(e,{verbose:t,fetch:Xt,token:er(e.provider)}),er=e=>{if(e.name==="http")return;let t=he().get(`${e.name}-token`);if(t)return t},kt=async e=>{let t=q(e);if(t){let r=await t.state(e,{token:er(t),fetch:Xt});return a(r)}return b(`Only ${p.map((r,o)=>`${o===p.length-1?"and ":""}${P.bold(r.name)}`).join(", ")} registries are supported at this time!`)},qe=async(...e)=>{let t=[],o=(await Promise.all(e.map(async n=>{let s=await kt(n);if(s.isErr())return b({message:s.unwrapErr(),repo:n});let i=s.unwrap();t.push(i);}))).find(n=>n!==undefined);return o||a(t)},We=async(...e)=>{let t=new Map,o=(await Promise.all(e.map(async n=>{let s=await Zt(n);if(s.isErr())return b({message:s.unwrapErr(),repo:n.url});let i=s.unwrap();for(let a of i.categories)for(let l of a.blocks)t.set(c(n.url,`${l.category}/${l.name}`),{...l,sourceRepo:n});}))).find(n=>n!==undefined);return o||a(t)};var Xe=async(e,t,r,o=new Map)=>{let n=new Map;for(let s of e){let i,a=q(s);if(a){let{url:f,specifier:m}=a.parse(s,{fullyQualified:true});i=t.get(c(f,m));}else {if(r.length===0)return b(P.red(`If your config doesn't contain repos then you must provide the repo in the block specifier ex: \`${P.bold(`github/ieedan/std/${s}`)}\`!`));for(let f of r){let{url:m,specifier:u}=f.provider.parse(c(f.url,s),{fullyQualified:true}),d=t.get(c(m,u));if(d!==undefined){i=d;break}}}if(!i)return b(`Invalid block! ${P.bold(s)} does not exist!`);let l=`${i.category}/${i.name}`;if(n.set(l,{name:i.name,subDependency:false,block:i}),i.localDependencies&&i.localDependencies.length>0){let f=await Xe(i.localDependencies.filter(m=>!n.has(m)&&!o.has(m)),t,r,n);if(f.isErr())return b(f.unwrapErr());for(let m of f.unwrap())n.set(`${m.block.category}/${m.block.name}`,m);}}return a(Or(n,(s,i)=>i))},Ze=(e,t,r)=>{let o=[],n=De(t.paths,r);n.isErr()&&program.error(P.red(n.unwrapErr()));let s=n.unwrap();for(let[i,a]of e){let l=ze(a,s,r),f=H.join(l,a.files[0]);a.subdirectory&&(f=H.join(l,a.name)),Oe.existsSync(f)&&o.push({specifier:`${a.category}/${a.name}`,path:f,block:a});}return o};var ve=e=>e.replace(zo(),"");var $t=(e,t,r=" ")=>{if(ve(e).length>t)throw new Error("String length is greater than the length provided.");return r.repeat(t-ve(e).length)+e};var qo=/\n|\r\n/g,Q=e=>e.split(qo),Z=(e,{lineNumbers:t=false,prefix:r}={})=>{let o=e;if(t){let n=e.length.toString().length+1;o=o.map((s,i)=>`${$t(`${i+1}`,n)} ${s}`);}return r!==undefined&&(o=o.map((n,s)=>`${r(s,e.length)}${n}`)),o.join(Ko.EOL)};var or=(e,t)=>{let r=H.join(e,"package.json");if(Oe.existsSync(r))return r;if(e===t)return;let o=e.split(/[\/\\]/);return or(o.slice(0,o.length-1).join("/"),t)},Uo=e=>{if(!Oe.existsSync(e))return b(`${e} doesn't exist`);let t=Oe.readFileSync(e).toString();return a(JSON.parse(t))},Wr=e=>e[0]==="^"?e.slice(1):e,Tt=(e,t,{cwd:r})=>{let o=e,n=t,s=Uo(H.join(r,"package.json"));if(!s.isErr()){let i=s.unwrap();if(i.dependencies)for(let a of o){let{name:l,version:f}=Ye(a).unwrap(),m=i.dependencies[l];if(f===undefined&&m){o.delete(a);continue}m&&Mr.satisfies(Wr(m),f)&&o.delete(a);}if(i.devDependencies)for(let a of n){let{name:l,version:f}=Ye(a).unwrap(),m=i.devDependencies[l];if(f===undefined&&m){n.delete(a);continue}m&&Mr.satisfies(Wr(m),f)&&n.delete(a);}}return {dependencies:o,devDependencies:n}};var Zo={matches:e=>e.endsWith(".css"),resolveDependencies:()=>a({dependencies:[],local:[],devDependencies:[],imports:{}}),comment:e=>`/*
${Z(Q(e),{prefix:()=>"	"})}
*/`,format:async(e,{formatter:t,prettierOptions:r,biomeOptions:o,filePath:n})=>{if(!t)return e;if(t==="prettier")return await Ne.format(e,{filepath:n,...r});let s=await Biome.create({distribution:Distribution.NODE});return o&&s.applyConfiguration(o),s.formatContent(e,{filePath:n}).content}},en={matches:e=>e.endsWith(".html"),resolveDependencies:({filePath:e,isSubDir:t,excludeDeps:r,dirs:o,cwd:n,containingDir:s})=>{let i=Oe.readFileSync(e).toString(),a$1=Kr.parse(i),l=[],f=(u,d)=>{if(u&&(d(u),u.childNodes&&u.childNodes.length>0))for(let c of u.childNodes)f(c,d);};for(let u of a$1.childNodes)f(u,d=>{if(d.tagName==="script")for(let c of d.attrs)c.name==="src"&&l.push(c.value);if(d.tagName==="link"&&d.attrs.find(c=>c.name==="rel"&&c.value==="stylesheet"))for(let c of d.attrs)c.name==="href"&&!c.value.startsWith("http")&&l.push(c.value);});let m=Mt({moduleSpecifiers:l,filePath:e,isSubDir:t,dirs:o,cwd:n,containingDir:s,doNotInstall:["svelte","@sveltejs/kit",...r]});return m.isErr()?b(m.unwrapErr().map(u=>_t(u)).join(`
`)):a(m.unwrap())},comment:e=>`<!--
${Z(Q(e),{prefix:()=>"	"})}
-->`,format:async(e,{formatter:t,prettierOptions:r})=>t&&t==="prettier"?await Ne.format(e,{parser:"html",...r}):e},nr={matches:e=>e.endsWith(".json"),resolveDependencies:()=>a({dependencies:[],local:[],devDependencies:[],imports:{}}),comment:e=>e,format:async(e,{formatter:t,prettierOptions:r,biomeOptions:o,filePath:n})=>{if(!t)return e;if(t==="prettier")return await Ne.format(e,{filepath:n,...r});let s=await Biome.create({distribution:Distribution.NODE});return o&&s.applyConfiguration(o),s.formatContent(e,{filePath:n}).content}},tn={matches:e=>e.endsWith(".jsonc"),resolveDependencies:()=>a({dependencies:[],local:[],devDependencies:[],imports:{}}),comment:e=>`/*
${Z(Q(e),{prefix:()=>"	"})}
*/`,format:async(e,{formatter:t,prettierOptions:r,biomeOptions:o,filePath:n})=>{if(!t)return e;if(t==="prettier")return await Ne.format(e,{filepath:n,...r});let s=await Biome.create({distribution:Distribution.NODE});return o&&s.applyConfiguration({...o,json:{parser:{allowComments:true}}}),s.formatContent(e,{filePath:n}).content}},rn={matches:e=>e.endsWith(".sass")||e.endsWith(".scss"),resolveDependencies:()=>a({dependencies:[],local:[],devDependencies:[],imports:{}}),comment:e=>`/*
${Z(Q(e),{prefix:()=>"	"})}
*/`,format:async(e,{formatter:t,prettierOptions:r})=>t&&t==="prettier"?await Ne.format(e,{parser:"scss",...r}):e},on={matches:e=>e.endsWith(".svelte"),resolveDependencies:({filePath:e,isSubDir:t,excludeDeps:r,dirs:o,cwd:n,containingDir:s})=>{let i=Oe.readFileSync(e).toString(),a$1=qr.parse(i,{modern:true,filename:e});if(!a$1.instance&&!a$1.module)return a({dependencies:[],devDependencies:[],local:[],imports:{}});let l=[],f=u=>{(u.type==="ImportDeclaration"||u.type==="ExportAllDeclaration"||u.type==="ExportNamedDeclaration")&&typeof u.source?.value=="string"&&l.push(u.source.value);};a$1.instance&&walk(a$1.instance,{enter:f}),a$1.module&&walk(a$1.module,{enter:f});let m=Mt({moduleSpecifiers:l,filePath:e,isSubDir:t,dirs:o,cwd:n,containingDir:s,doNotInstall:["svelte","@sveltejs/kit",...r]});return m.isErr()?b(m.unwrapErr().map(u=>_t(u)).join(`
`)):a(m.unwrap())},comment:e=>`<!--
${Z(Q(e),{prefix:()=>"	"})}
-->`,format:async(e,{formatter:t,filePath:r,prettierOptions:o})=>t&&t==="prettier"&&o&&o.plugins?.find(n=>n==="prettier-plugin-svelte")?await Ne.format(e,{filepath:r,...o}):e},nn={matches:e=>e.endsWith(".svg"),resolveDependencies:()=>a({dependencies:[],local:[],devDependencies:[],imports:{}}),comment:e=>`<!--
${Z(Q(e),{prefix:()=>"	"})}
-->`,format:async e=>e},sn={matches:e=>e.endsWith(".ts")||e.endsWith(".js")||e.endsWith(".tsx")||e.endsWith(".jsx"),resolveDependencies:({filePath:e,isSubDir:t,excludeDeps:r,dirs:o,cwd:n,containingDir:s})=>{let a$1=new Project().addSourceFileAtPath(e),l=a$1.getImportDeclarations().map(u=>u.getModuleSpecifierValue()),f=a$1.getExportDeclarations().map(u=>u.getModuleSpecifierValue()).filter(u=>u!==undefined);l.push(...f);let m=Mt({moduleSpecifiers:l,filePath:e,isSubDir:t,dirs:o,cwd:n,containingDir:s,doNotInstall:r});return m.isErr()?b(m.unwrapErr().map(u=>_t(u)).join(`
`)):a(m.unwrap())},comment:e=>`/*
${Z(Q(e),{prefix:()=>"	"})}
*/`,format:async(e,{formatter:t,filePath:r,prettierOptions:o,biomeOptions:n})=>{if(!t)return e;if(t==="prettier")return await Ne.format(e,{filepath:r,...o});let s=await Biome.create({distribution:Distribution.NODE});return n&&s.applyConfiguration(n),s.formatContent(e,{filePath:r}).content}},an={matches:e=>e.endsWith(".vue"),resolveDependencies:({filePath:e,isSubDir:t,excludeDeps:r,dirs:o,cwd:n,containingDir:s})=>{let i=Oe.readFileSync(e).toString(),a$1=Lt.parse(i,{filename:e});if(!a$1.descriptor.script?.content&&!a$1.descriptor.scriptSetup?.content)return a({dependencies:[],devDependencies:[],local:[],imports:{}});let l;try{l=Lt.compileScript(a$1.descriptor,{id:"shut-it"});}catch(u){return b(`Compile error: ${u}`)}if(!l.imports)return a({dependencies:[],devDependencies:[],local:[],imports:{}});let f=Object.values(l.imports).map(u=>u.source),m=Mt({moduleSpecifiers:f,filePath:e,isSubDir:t,dirs:o,cwd:n,containingDir:s,doNotInstall:["vue","nuxt",...r]});return m.isErr()?b(m.unwrapErr().map(u=>_t(u)).join(`
`)):a(m.unwrap())},comment:e=>`<!--
${Z(Q(e),{prefix:()=>"	"})}
-->`,format:async(e,{formatter:t,prettierOptions:r})=>t&&t==="prettier"?await Ne.format(e,{parser:"vue",...r}):e},cn={matches:e=>e.endsWith(".yml")||e.endsWith(".yaml"),resolveDependencies:()=>a({dependencies:[],local:[],devDependencies:[],imports:{}}),comment:e=>Z(Q(e),{prefix:()=>"# "}),format:async(e,{formatter:t,prettierOptions:r})=>t&&t==="prettier"?await Ne.format(e,{parser:"yaml",...r}):e},_t=e=>`${Z(Q(e),{prefix:t=>t===0?`${B}  ${It} `:`${B}  `})}`,Mt=({moduleSpecifiers:e,isSubDir:t,filePath:r,containingDir:o,doNotInstall:n,dirs:s,cwd:i})=>{let a$1=[],l=new Set,f=new Set,m={};for(let c of e){if(c.startsWith(".")){let y=Ur(c,t,{filePath:r,containingDir:o,dirs:s,cwd:i});if(y.isErr()){a$1.push(y.unwrapErr());continue}let w=y.unwrap();w&&(f.add(w.dependency),m[c]=w.template);continue}let $=ln(c,t,{filePath:r,containingDir:o,dirs:s,cwd:i});if($.isErr()){a$1.push($.unwrapErr());continue}let C=$.unwrap();C?(f.add(C.dependency),m[c]=C.template):l.add(c);}if(a$1.length>0)return b(a$1);let{devDependencies:u,dependencies:d}=fn(Array.from(l),r,{doNotInstall:n||[]});return a({dependencies:d,devDependencies:u,local:Array.from(f),imports:m})},Ur=(e,t,{filePath:r,containingDir:o,dropExtension:n=true,alias:s,dirs:i,cwd:a$1})=>{if(t&&(e.startsWith("./")||e==="."))return a(undefined);let l=t?H.join(o,"../"):H.join(r,"../"),f=H.join(H.join(r,"../"),e),m=H.join(l,"../");if(o&&f.startsWith(o))return a(undefined);if(f.startsWith(m))return a(zr(f.slice(m.length),n));for(let u of i){let d=H.resolve(H.join(a$1,u)),c=H.resolve(f);if(c.startsWith(d))return a(zr(c.slice(d.length+1),n))}return b(`${r}:
${s||e} references code not contained in ${P.bold(i.join(", "))} and cannot be resolved.`)},zr=(e,t=true)=>{let[r,o,...n]=e.split("/");o===undefined&&(o="index");let s=o;t&&s.includes(".")&&(s=s.slice(0,s.length-H.parse(s).ext.length));let i=`${r}/${s}`,a=`{{${i}}}`;return n.length===0?s.length!==o.length&&(a+=H.parse(o).ext):a+=`/${n.join("/")}`,{dependency:i,template:a}},ln=(e,t,{filePath:r,dirs:o,cwd:n,containingDir:s})=>{let i;try{if(i=getTsconfig(r,"tsconfig.json"),!i&&(i=getTsconfig(r,"jsconfig.json"),!i))return a(void 0)}catch(l){return b(`Error while trying to get ${P.bold("tsconfig.json")}: ${l}`)}let a$1=createPathsMatcher(i);if(a$1){let l=a$1(e);for(let f of l){let m=pn(f);if(!m)continue;let u=H.relative(H.resolve(H.join(r,"../")),m.prettyPath),d=dn(m.prettyPath,m.path,[".js",".ts"]),c=Ur(u,t,{filePath:r,containingDir:s,alias:e,dropExtension:d,dirs:o,cwd:n,modIsFile:m.type==="file"});if(c.isErr())return b(c.unwrapErr());if(c.unwrap())return a(c.unwrap());break}}return a(undefined)},dn=(e,t,r=[".ts",".js",""])=>{if(e===t)return  true;let o=H.parse(e),n=H.parse(t),s=H.join(o.dir,o.name),i=H.join(n.dir,n.name);return s!==i?false:!!(r.includes(o.ext)&&r.includes(n.ext))},pn=e=>{if(Oe.existsSync(e))return {path:e,prettyPath:e,type:Oe.statSync(e).isDirectory()?"directory":"file"};let t=H.join(e,"../");if(!Oe.existsSync(t))return;let r=H.parse(e);if(r.ext===".js"){let n=`${e.slice(0,e.length-3)}.ts`;if(Oe.existsSync(n))return {path:n,prettyPath:e,type:"file"}}let o=Oe.readdirSync(t);for(let n of o){let s=H.parse(n);if(s.name===r.base){let i=H.join(t,n),a=i.slice(0,i.length-s.ext.length);return {path:i,prettyPath:a,type:Oe.statSync(i).isDirectory()?"directory":"file"}}}},fn=(e,t,{doNotInstall:r}={doNotInstall:[]})=>{let o=new Set(r),n=e.filter(l=>!builtinModules.includes(l)&&!l.startsWith("node:")),s=or(H.dirname(t),""),i=new Set,a=new Set;if(s){let{devDependencies:l,dependencies:f}=JSON.parse(Oe.readFileSync(s,"utf-8"));for(let m of n){let u=Ye(m);if(u.isErr()){console.warn(`${B}  ${xe} Skipped adding import \`${P.cyan(m)}\`. Reason: Couldn't parse package name`);continue}let d=u.unwrap();if(!Xo(d.name).validForNewPackages){console.warn(`${B}  ${xe} Skipped adding import \`${P.cyan(m)}\`. Reason: Not a valid package name`);continue}if(o.has(d.name))continue;let c;if(f!==undefined&&(c=f[d.name]),c!==undefined){i.add(`${d.name}@${c}`);continue}if(l!==undefined&&(c=l[d.name]),c!==undefined){a.add(`${d.name}@${c}`);continue}i.add(d.name);}}return {dependencies:Array.from(i),devDependencies:Array.from(a)}},dt=[Zo,en,nr,tn,rn,on,nn,sn,an,cn];var Xr=[".test.ts","_test.ts",".test.js","_test.js"],Te=e=>Xr.find(t=>e.endsWith(t))!==undefined,Zr=(e,{cwd:t,ignore:r,config:o})=>{let n;try{n=Oe.readdirSync(e);}catch{program.error(P.red(`Couldn't read the ${P.bold(e)} directory.`));}let s=[];for(let i of n){let a=H.join(e,i);if(Oe.statSync(a).isFile())continue;let l=`${H.relative(t,a)}/`;if(r.ignores(l))continue;let f=H.basename(i);if(!un(f,o))continue;let m=mn(f,o),u={name:f,blocks:[]},d=Oe.readdirSync(a);for(let c of d){let $=H.join(a,c);if(Oe.statSync($).isFile()){if(Te(c))continue;let C=gn(c),y=Hr(C,o);if(!Yr(C,o))continue;let w=dt.find(E=>E.matches(c));if(!w){console.warn(`${B}  ${xe} Skipped \`${P.bold($)}\` \`*${P.bold(H.parse(c).ext)}\` files are not currently supported!`);continue}let h=d.find(E=>Xr.find(j=>E===`${C}${j}`)),{dependencies:L,devDependencies:J,local:U,imports:g}=w.resolveDependencies({filePath:$,isSubDir:false,excludeDeps:o.excludeDeps,dirs:o.dirs,cwd:t}).match(E=>E,E=>{program.error(P.red(E));}),R={name:C,directory:H.relative(t,a),category:f,tests:h!==undefined,subdirectory:false,list:m?y:false,files:[c],localDependencies:U,_imports_:g,dependencies:L,devDependencies:J};h!==undefined&&R.files.push(h),u.blocks.push(R);}else {let C=c,y=Hr(C,o);if(!Yr(C,o))continue;let w=new Set,h=new Set,L=new Set,J={},U=false,g=[],R=(j,z)=>{for(let X of z){let v=H.join(j,X),p=v.slice($.length+1);if(Te(X)){U=true,g.push(p);continue}if(Oe.statSync(v).isDirectory()){if(!o.allowSubdirectories){console.warn(`${B}  ${xe} Skipped \`${P.bold(H.join($,X))}\` subdirectories are not allowed! Allow them with ${P.bold("--allow-subdirectories")}!`);continue}let O=Oe.readdirSync(v);R(v,O);continue}let b=dt.find(O=>O.matches(X));if(!b){console.warn(`${B}  ${xe} Skipped \`${v}\` \`*${P.bold(H.parse(X).ext)}\` files are not currently supported!`);continue}let{local:x,dependencies:A,devDependencies:K,imports:F}=b.resolveDependencies({isSubDir:true,excludeDeps:o.excludeDeps,dirs:o.dirs,containingDir:$,filePath:v,cwd:t}).match(O=>O,O=>{program.error(P.red(O));});for(let O of x)O!==`${f}/${C}`&&w.add(O);for(let O of A)h.add(O);for(let O of K)L.add(O);for(let[O,ae]of Object.entries(F))J[O]=ae;g.push(p);}};R($,Oe.readdirSync($));let E={name:C,directory:H.relative(t,$),category:f,tests:U,subdirectory:true,list:m?y:false,files:g,localDependencies:Array.from(w.keys()),dependencies:Array.from(h.keys()),devDependencies:Array.from(L.keys()),_imports_:J};u.blocks.push(E);}}s.push(u);}return s},Hr=(e,t)=>t.doNotListBlocks.length>0&&t.doNotListBlocks.includes(e)?false:t.listBlocks.length>0?t.listBlocks.includes(e):true,Yr=(e,t)=>t.excludeBlocks.length>0&&t.excludeBlocks.includes(e)?false:t.includeBlocks.length>0?t.includeBlocks.includes(e):true,mn=(e,t)=>t.doNotListCategories.length>0&&t.doNotListCategories.includes(e)?false:t.listCategories.length>0?t.listCategories.includes(e):true,un=(e,t)=>t.excludeCategories.length>0&&t.excludeCategories.includes(e)?false:t.includeCategories.length>0?t.includeCategories.includes(e):true,gn=e=>H.parse(H.basename(e)).name,eo=e=>{let t=[];for(let o of e){let n=[];for(let s of o.blocks){let i=`${s.category}/${s.name}`;!s.list&&!Fr(i,e)||n.push(s);}n.length>0&&t.push({name:o.name,blocks:n});}return [t,0]};var yn={"no-workspace":"--no-workspace","install-as-dev-dependency":"-D"},hn={"install-as-dev-dependency":"-D"},vn={"no-workspace":"--workspaces=false","install-as-dev-dependency":"-D"},to={"no-workspace":"--ignore-workspace","install-as-dev-dependency":"-D"},ro={"no-workspace":"--focus","install-as-dev-dependency":"-D"},ir={bun:yn,npm:vn,pnpm:to,deno:hn,yarn:ro,"yarn@berry":ro,"pnpm@6":to};var je=async({pm:e,deps:t,dev:r,cwd:o,ignoreWorkspace:n=false})=>{let s=[...t];r&&s.push(ir[e]["install-as-dev-dependency"]);let i=ir[e]["no-workspace"];n&&i&&s.push(i);let a$1=resolveCommand$1(e,"add",s);if(a$1==null)return b(P.red(`Could not resolve add command for '${e}'.`));try{return await execa(a$1.command,[...a$1.args],{cwd:o}),a(t)}catch{return b(P.red(`Failed to install ${P.bold(t.join(", "))}! Failed while running '${P.bold(`${a$1.command} ${a$1.args.join(" ")}`)}'`))}},$n=/\{\{([^\/]+)\/([^\}]+)\}\}/g,oo=({template:e,config:t,destPath:r,cwd:o})=>{let n=H.join(r,"../");return e.replace($n,(s,i,a)=>{if(t.paths[i]===undefined){if(t.paths["*"].startsWith(".")){let l=H.relative(n,H.join(o,t.paths["*"],i,a));return l.startsWith(".")?l:`./${l}`}return H.join(t.paths["*"],i,a)}if(t.paths[i].startsWith(".")){let l=H.relative(n,H.join(o,t.paths[i],a));return l.startsWith(".")?l:`./${l}`}return H.join(t.paths[i],a)})};var Vt=async({file:e,config:t,imports:r,watermark:o,prettierOptions:n,biomeOptions:s,cwd:i,verbose:a$1})=>{let l=dt.find(m=>m.matches(e.destPath)),f=e.content;if(l){t.watermark&&(f=`${l.comment(o)}

${f}`),a$1?.(`Formatting ${P.bold(e.destPath)}`);try{f=await l.format(f,{filePath:e.destPath,formatter:t.formatter,prettierOptions:n,biomeOptions:s});}catch(m){return b(`Error formatting ${P.bold(e.destPath)} ${m}`)}}for(let[m,u]of Object.entries(r)){let d=oo({template:u,config:t,destPath:e.destPath,cwd:i}),c=new RegExp(`(['"])${bn(m)}\\1`,"g");f=f.replaceAll(c,`$1${d}$1`);}return a(f)},so=async({file:e,config:t,prettierOptions:r,biomeOptions:o})=>{let n=dt.find(i=>i.matches(e.destPath)),s=e.content;if(n)try{s=await n.format(e.content,{filePath:e.destPath,formatter:t.formatter,prettierOptions:r,biomeOptions:o});}catch{return s}return s};var pt=async({formatter:e,cwd:t})=>{let r=null;e==="prettier"&&(r=await Ne.resolveConfig(H.join(t,".prettierrc")));let o=null;if(e==="biome"){let n=H.join(t,"biome.json");Oe.existsSync(n)&&(o=JSON.parse(Oe.readFileSync(n).toString()));}return {biomeOptions:o,prettierOptions:r}};var Jt=(e,t)=>`jsrepo ${e}
Installed from ${t}
${new Date().toLocaleDateString().replaceAll("/","-")}`;var bt=async(e,{verbose:t=undefined})=>{let r=spinner();for(let o of e){t?t(o.loadingMessage):r.start(o.loadingMessage);try{await o.run();}catch(n){r.stop(`Error while ${o.loadingMessage}`),console.error(n);}t?t(o.completedMessage):r.stop(o.completedMessage);}},Gt=async({tasks:e,startMessage:t,stopMessage:r,verbose:o})=>{let n=spinner(),s=i=>{o?o(i):n.message(i);};o?o(t):n.start(t),await Promise.all([...e.map(i=>i.run({message:s}))]),o?o(r):n.stop(r);},Sn={padding:1,borderColor:"gray",borderStyle:{topLeft:ve(Ut),bottomLeft:ve(Ut),topRight:ve(Er),top:ve(qt),bottom:ve(qt),bottomRight:ve(Dr),left:ve(B),right:ve(B)}},ft=e=>{let t=po(e.join(`
`),{...Sn,title:"Next Steps",textAlignment:"left"});return `${B}
${t}
`},fo=(e,t=3)=>{let r=e.slice(0,t),o=e.length-r.length;return `${r.join(", ")}${o>0?` and ${o} other(s)`:""}`},Pn=(e,t,r)=>{let o=detectSync({cwd:process.cwd()})?.agent??"npm",n=resolveCommand$1(o,"global",["jsrepo@latest"]),s=[`Update available! ${P.redBright(t)} -> ${P.greenBright(r)}`,`${P.cyan("Changelog")}: https://github.com/ieedan/jsrepo/releases/tag/${e}@${r}`,`Run ${P.cyan(`${n?.command} ${n?.args.join(" ")}`)} to update!`,"",`${P.yellowBright("Star")} on GitHub for updates: https://github.com/ieedan/jsrepo`];return po(s.join(`
`),{borderColor:"gray",padding:1,margin:1,textAlignment:"center"})},de=({package:e})=>{console.clear(),e.latestVersion&&Mr.lt(e.version,e.latestVersion)&&console.info(Pn(e.name,e.version,e.latestVersion)),intro(`${P.bgHex("#f7df1e").black(` ${e.name} `)}${P.gray(` v${e.version} `)}`);};var Bn=k.object({repo:k.optional(k.string()),allow:k.boolean(),yes:k.boolean(),verbose:k.boolean(),cwd:k.string()}),ar=new Command("add").description("Add blocks to your project.").argument("[blocks...]","Names of the blocks you want to add to your project. ex: (utils/math, github/ieedan/std/utils/math)").option("--repo <repo>","Repository to download the blocks from.").option("-A, --allow","Allow jsrepo to download code from the provided repo.",false).option("-y, --yes","Skip confirmation prompt.",false).option("--verbose","Include debug logs.",false).option("--cwd <path>","The current working directory.",process.cwd()).action(async(e,t)=>{let r=k.parse(Bn,t);de(te),await Ln(e,r),outro(P.green("All done!"));}),Ln=async(e,t)=>{let r=v=>{t.verbose&&console.info(`${at} ${v}`);};r(`Attempting to add ${JSON.stringify(e)}`);let o=spinner(),n=Ee(t.cwd),s=n.isErr(),i;if(n.isErr()){let v=t.yes;if(!t.yes){let p=await confirm({message:`You don't have ${fe} initialized in your project. Do you want to continue?`,initialValue:false});isCancel(p)&&(cancel("Canceled!"),process.exit(0)),v=p;}v||(cancel("Canceled!"),process.exit(0)),i={$schema:"",includeTests:false,watermark:true,paths:{"*":"./src/blocks"},repos:[]};}else i=n.unwrap();let a=i.repos,l=new Set,f=false;t.repo&&(a=[t.repo]);for(let v of e){let p=q(v);if(!p){f=true;continue}let{url:b}=p.parse(v,{fullyQualified:true});if(!(!i.repos.find(A=>A===b)&&!l.has(b))){if(!t.allow){let A=await confirm({message:`Allow ${fe} to download and run code from ${P.cyan(b)}?`,initialValue:true});(isCancel(A)||!A)&&(cancel("Canceled!"),process.exit(0));}a.push(b);}l.add(b);}if(!f&&e.length>0&&(a=Array.from(l)),!t.allow&&t.repo){let v=await confirm({message:`Allow ${fe} to download and run code from ${P.cyan(t.repo)}?`,initialValue:true});(isCancel(v)||!v)&&(cancel("Canceled!"),process.exit(0));}a.length===0&&(s&&program.error(P.red(`Fully quality blocks ex: (github/ieedan/std/utils/math) or provide the \`${P.bold("--repo")}\` flag to specify a registry.`)),program.error(P.red(`There were no repos present in your config and you didn't provide the \`${P.bold("--repo")}\` flag with a repo.`))),r(`Resolving ${P.cyan(a.join(", "))}`),t.verbose||o.start(`Fetching blocks from ${P.cyan(a.join(", "))}`);let m=(await qe(...a)).match(v=>v,({repo:v,message:p})=>{o.stop(`Failed to get info for ${P.cyan(v)}`),program.error(P.red(p));});r(`Resolved ${P.cyan(a.join(", "))}`),r(`Fetching blocks from ${P.cyan(a.join(", "))}`);let u=(await We(...m)).match(v=>v,({repo:v,message:p})=>{o.stop(`Failed fetching blocks from ${P.cyan(v)}`),program.error(P.red(p));});t.verbose||o.stop(`Retrieved blocks from ${P.cyan(a.join(", "))}`),r(`Retrieved blocks from ${P.cyan(a.join(", "))}`);let d=Ze(u,i,t.cwd).map(v=>v.specifier),c$1=e;if(c$1.length===0){let v=await multiselect({message:"Select which blocks to add.",options:Array.from(u.entries()).filter(([p,b])=>b.list).map(([p,b])=>{let x=`${b.category}/${b.name}`,A=d.findIndex(F=>F===x)!==-1,K;return a.length>1?K=`${P.cyan(c(b.sourceRepo.url,b.category))}/${b.name}`:K=`${P.cyan(b.category)}/${b.name}`,{label:A?P.gray(K):K,value:p,hint:A?"Installed":undefined}}),required:true});isCancel(v)&&(cancel("Canceled!"),process.exit(0)),c$1=v;}r(`Installing blocks ${P.cyan(c$1.join(", "))}`);let $=(await Xe(c$1,u,m)).match(v=>v,v=>program.error(v)),C=(await detect({cwd:t.cwd}))?.agent??"npm",y=[],w=new Set,h=new Set,L=he();if(s){let v=`${t.cwd}-zero-config`,p=k.safeParse(Qt,L.get(v)),b=p.success?p.output:i,x=Array.from(new Set($.map(F=>F.block.category)));for(let F of x){let O=await text({message:`Where would you like to add ${P.cyan(F)}?`,placeholder:b?b.paths[F]:`./src/${F}`,initialValue:b?b.paths[F]:`./src/${F}`,defaultValue:b?b.paths[F]:`./src/${F}`,validate(ae){if(ae.trim()==="")return "Please provide a value"}});isCancel(O)&&(cancel("Canceled!"),process.exit(0)),i.paths[F]=O;}if(!t.yes){let F=await confirm({message:"Include tests?",initialValue:b.includeTests});isCancel(F)&&(cancel("Canceled!"),process.exit(0)),i.includeTests=F;let O=await confirm({message:"Add watermark?",initialValue:b.watermark});isCancel(O)&&(cancel("Canceled!"),process.exit(0)),i.watermark=O;}let A="none";Oe.existsSync(H.join(t.cwd,".prettierrc"))&&(A="prettier"),Oe.existsSync(H.join(t.cwd,"biome.json"))&&(A="biome");let K=await select({message:"What formatter would you like to use?",options:["Prettier","Biome","None"].map(F=>({value:F.toLowerCase(),label:F})),initialValue:A==="none"?b.formatter?b.formatter:"none":A});isCancel(K)&&(cancel("Canceled!"),process.exit(0)),K!=="none"&&(i.formatter=K),L.set(v,i),d=Ze(u,i,t.cwd).map(F=>F.specifier);}let{prettierOptions:J,biomeOptions:U}=await pt({formatter:i.formatter,cwd:t.cwd}),g=De(i.paths,t.cwd);g.isErr()&&program.error(P.red(g.unwrapErr()));let R=g.unwrap(),E=[],j;for(let{block:v}of $){let p=c(v.sourceRepo.url,v.category,v.name),b=`${v.category}/${v.name}`,x=Jt(te.package.version,v.sourceRepo.url),A=v.sourceRepo;r(`Setting up ${p}`);let K=ze(v,R,t.cwd);if(d.find(O=>b===O)&&!t.yes&&!j){if(j===undefined){let O=$.map(M=>`${M.block.category}/${M.block.name}`).filter(M=>d.find(W=>W===M));log.warn(`The following components ${P.bold.yellow("already exist")}: ${P.cyan(fo(O))}`);let ae=await confirm({message:`Would you like to ${P.bold.red("overwrite")} all existing components?`,active:"Yes, overwrite everything",inactive:"No, let me decide individually",initialValue:false});isCancel(ae)&&(cancel("Canceled!"),process.exit(0)),j=ae;}if(!j){let O=await confirm({message:`${P.cyan(b)} already exists in your project would you like to overwrite it?`,initialValue:false});if(isCancel(O)&&(cancel("Canceled!"),process.exit(0)),!O)continue}}E.push(b),y.push({run:async({message:O})=>{O(`Adding ${P.cyan(p)}`),r(`Creating directory ${P.bold(K)}`),Oe.mkdirSync(K,{recursive:true}),r(`Created directory ${P.bold(K)}`);let ae=[],M=async W=>{let q=await Ke(A,W,{verbose:r});return q.isErr()&&(o.stop(P.red(`Error fetching ${P.bold(W)}`)),program.error(P.red(`There was an error trying to get ${p}`))),q.unwrap()};for(let W of v.files){if(!i.includeTests&&Te(W))continue;let q=H.join(v.directory,W),ce;v.subdirectory?ce=H.join(K,v.name,W):ce=H.join(K,W),r(`Adding ${P.bold(q)}`);let ye=await M(q),it=ce.slice(0,ce.length-W.length);r(`Creating directory ${P.bold(it)}`),Oe.mkdirSync(it,{recursive:true}),r(`Created directory ${P.bold(it)}`),ae.push({content:ye,destPath:ce}),r(`Got ${P.bold(q)}`);}for(let W of ae){let q=await Vt({file:W,biomeOptions:U,prettierOptions:J,config:i,imports:v._imports_,watermark:x,verbose:r,cwd:t.cwd});q.isErr()&&program.error(P.red(q.unwrapErr())),r(`Writing to ${P.bold(W.destPath)}`),Oe.writeFileSync(W.destPath,q.unwrap());}if(i.includeTests&&v.tests){r("Trying to include tests");let{devDependencies:W}=JSON.parse(Oe.readFileSync(H.join(t.cwd,"package.json")).toString());(W===undefined||W.vitest===undefined)&&w.add("vitest");}for(let W of v.devDependencies)w.add(W);for(let W of v.dependencies)h.add(W);}});}await Gt({startMessage:"Adding blocks",stopMessage:`Added ${P.cyan(E.join(", "))}`,tasks:y,verbose:t.verbose?r:undefined});let z=Tt(h,w,{cwd:t.cwd});if(h=z.dependencies,w=z.devDependencies,h.size>0||w.size>0){let v=t.yes;if(!t.yes){let x=await confirm({message:"Would you like to install dependencies?",initialValue:true});isCancel(x)&&(cancel("Canceled!"),process.exit(0)),v=x;}v&&(h.size>0&&(t.verbose||o.start(`Installing dependencies with ${P.cyan(C)}`),(await je({pm:C,deps:Array.from(h),dev:false,cwd:t.cwd})).match(x=>{t.verbose||o.stop(`Installed ${P.cyan(x.join(", "))}`);},x=>{t.verbose||o.stop("Failed to install dependencies"),program.error(x);})),w.size>0&&(t.verbose||o.start(`Installing dependencies with ${P.cyan(C)}`),(await je({pm:C,deps:Array.from(w),dev:true,cwd:t.cwd})).match(x=>{t.verbose||o.stop(`Installed ${P.cyan(x.join(", "))}`);},x=>{t.verbose||o.stop("Failed to install dev dependencies"),program.error(x);})));let p=[];if(!v){if(h.size>0){let x=resolveCommand(C,"add",[...h]);p.push(`Install dependencies \`${P.cyan(`${x?.command} ${x?.args.join(" ")}`)}\``);}if(w.size>0){let x=resolveCommand(C,"add",[...w,"-D"]);p.push(`Install dev dependencies \`${P.cyan(`${x?.command} ${x?.args.join(" ")}`)}\``);}}p=p.map((x,A)=>`${A+1}. ${x}`),v||p.push(""),p.push("Import and use the blocks!");let b=ft(p);process.stdout.write(b);}};var zn=k.object({token:k.optional(k.string()),provider:k.optional(k.string()),logout:k.boolean()}),gt=p.filter(e=>e.name!==o.name),dr=new Command("auth").description("Provide a token for access to private repositories.").option("--token <token>","The token to use for authenticating to your provider.").addOption(new Option("--provider <name>","The provider this token belongs to.").choices(gt.map(e=>e.name))).option("--logout","Erase tokens from each provider from storage.",false).action(async e=>{let t=k.parse(zn,e);de(te),await Kn(t),outro(P.green("All done!"));}),Kn=async e=>{let t=he();if(e.logout){for(let r of gt){let o=`${r.name}-token`;if(t.get(o)===undefined){process.stdout.write(`${B}
`),process.stdout.write(P.gray(`${B}  Already logged out of ${r.name}.
`));continue}let n=await confirm({message:`Remove ${r.name} token?`,initialValue:true});isCancel(n)&&(cancel("Canceled!"),process.exit(0)),n&&t.delete(o);}return}if(gt.length>1){let r=await select({message:"Which provider is this token for?",options:gt.map(o=>({label:o.name,value:o.name})),initialValue:gt[0].name});isCancel(r)&&(cancel("Canceled!"),process.exit(0)),e.provider=r;}else e.provider=gt[0].name;if(e.token===undefined){let r=await password({message:"Paste your token",validate(o){if(o.trim()==="")return "Please provide a value"}});(isCancel(r)||!r)&&(cancel("Canceled!"),process.exit(0)),e.token=r;}t.set(`${e.provider}-token`,e.token);};var Qn=[".git","node_modules"],Xn=k.object({dirs:k.optional(k.array(k.string())),outputDir:k.optional(k.string()),includeBlocks:k.optional(k.array(k.string())),includeCategories:k.optional(k.array(k.string())),excludeBlocks:k.optional(k.array(k.string())),excludeCategories:k.optional(k.array(k.string())),excludeDeps:k.optional(k.array(k.string())),listBlocks:k.optional(k.array(k.string())),listCategories:k.optional(k.array(k.string())),doNotListBlocks:k.optional(k.array(k.string())),doNotListCategories:k.optional(k.array(k.string())),allowSubdirectories:k.optional(k.boolean()),preview:k.optional(k.boolean()),output:k.boolean(),verbose:k.boolean(),cwd:k.string()}),pr=new Command("build").description(`Builds the provided --dirs in the project root into a \`${h}\` file.`).option("--dirs [dirs...]","The directories containing the blocks.").option("--output-dir <dir>","The directory to output the registry to. (Copies jsrepo-manifest.json + all required files)").option("--include-blocks [blockNames...]","Include only the blocks with these names.").option("--include-categories [categoryNames...]","Include only the categories with these names.").option("--exclude-blocks [blockNames...]","Do not include the blocks with these names.").option("--exclude-categories [categoryNames...]","Do not include the categories with these names.").option("--list-blocks [blockNames...]","List only the blocks with these names.").option("--list-categories [categoryNames...]","List only the categories with these names.").option("--do-not-list-blocks [blockNames...]","Do not list the blocks with these names.").option("--do-not-list-categories [categoryNames...]","Do not list the categories with these names.").option("--exclude-deps [deps...]","Dependencies that should not be added.").option("--allow-subdirectories","Allow subdirectories to be built.").option("--preview","Display a preview of the blocks list.").option("--no-output",`Do not output a \`${h}\` file.`).option("--verbose","Include debug logs.",false).option("--cwd <path>","The current working directory.",process.cwd()).action(async e=>{let t=k.parse(Xn,e);de(te),await Zn(t),outro(P.green("All done!"));}),Zn=async e=>{let t=spinner(),r=[],o=Ot(e.cwd).match(d=>{if(d===null)return {$schema:"",dirs:e.dirs??[],outputDir:e.outputDir,doNotListBlocks:e.doNotListBlocks??[],doNotListCategories:e.doNotListCategories??[],listBlocks:e.listBlocks??[],listCategories:e.listCategories??[],excludeDeps:e.excludeDeps??[],includeBlocks:e.includeBlocks??[],includeCategories:e.includeCategories??[],excludeBlocks:e.excludeBlocks??[],excludeCategories:e.excludeCategories??[],allowSubdirectories:e.allowSubdirectories,preview:e.preview};let c=d;return e.dirs&&(c.dirs=e.dirs),e.outputDir&&(c.outputDir=e.outputDir),e.doNotListBlocks&&(c.doNotListBlocks=e.doNotListBlocks),e.doNotListCategories&&(c.doNotListCategories=e.doNotListCategories),e.listBlocks&&(c.listBlocks=e.listBlocks),e.listCategories&&(c.listCategories=e.listCategories),e.includeBlocks&&(c.includeBlocks=e.includeBlocks),e.includeCategories&&(c.includeCategories=e.includeCategories),e.excludeBlocks&&(c.excludeBlocks=e.excludeBlocks),e.excludeCategories&&(c.excludeCategories=e.excludeCategories),e.excludeDeps&&(c.excludeDeps=e.excludeDeps),e.allowSubdirectories!==undefined&&(c.allowSubdirectories=e.allowSubdirectories),e.preview!==undefined&&(c.preview=e.preview),c.rules={...Ht,...c.rules},c},d=>program.error(P.red(d))),n;o.outputDir?n=H.join(e.cwd,o.outputDir):n=e.cwd;let s=H.join(n,h);if(e.output&&Oe.existsSync(s)){if(o.outputDir){let d=j(Oe.readFileSync(s).toString());if(d.isOk())for(let c of d.unwrap().categories)for(let $ of c.blocks){let C=H.join(n,$.directory);Oe.existsSync(C)&&Oe.rmSync(C,{recursive:true});}}Oe.rmSync(s);}let i=Yn();try{let d=Oe.readFileSync(H.join(e.cwd,".gitignore")).toString();i.add(d);}catch{}i.add(Qn);for(let d of o.dirs){let c=H.join(e.cwd,d);t.start(`Building ${P.cyan(c)}`);let $=Zr(c,{cwd:e.cwd,ignore:i,config:o});for(let C of $){if(r.find(y=>y.name===C.name)!==undefined){console.warn(`${B}  ${xe} Skipped adding \`${P.cyan(`${d}/${C.name}`)}\` because a category with the same name already exists!`);continue}r.push(C);}t.stop(`Built ${P.cyan(c)}`);}let a=es(r,o);t.start("Checking manifest");let{warnings:l,errors:f}=Ar(a,o,o.rules);t.stop("Completed checking manifest."),(l.length>0||f.length>0)&&console.log(B);for(let d of l)console.log(d);if(f.length>0){for(let d of f)console.log(d);program.error(P.red(`Completed checking manifest with ${P.bold(`${f.length} error(s)`)} and ${P.bold(`${l.length} warning(s)`)}`));}let[m,u]=eo(r);if(r=m,u>0&&log.step(`Removed ${u} unused block${u>1?"s":""}.`),o.preview){let d=r.flatMap(c=>c.blocks.filter($=>$.list).map($=>`${P.cyan($.category)}/${$.name}`));log.message(`${P.yellow("Preview")}:`);for(let c of d)console.log(`${B}  \u25FB ${c}`);}if(e.output){if(o.outputDir){t.start(`Copying registry files to \`${P.cyan(n)}\``);for(let d of r)for(let c of d.blocks){let $=H.join(e.cwd,c.directory),C=H.join(n,c.directory);for(let y of c.files){let w=H.join(C,y,"../");Oe.existsSync(w)||Oe.mkdirSync(w,{recursive:true}),Oe.copyFileSync(H.join($,y),H.join(C,y));}}t.stop(`Copied registry files to \`${P.cyan(n)}\``);}t.start(`Writing output to \`${P.cyan(s)}\``),Oe.writeFileSync(s,JSON.stringify(a,null,"	")),t.stop(`Wrote output to \`${P.cyan(s)}\``);}},es=(e,t)=>({meta:t.meta,categories:e});var cs=k.objectWithRest({repo:k.optional(k.string()),allow:k.boolean(),cwd:k.string()},k.unknown()),ur=new Command("exec").alias("x").description("Execute a block as a script.").addArgument(new Argument("script","Name of the script you want to execute. ex: (general/hello, github/ieedan/std/general/hello)").argOptional()).option("--repo <repo>","Repository to download and run the script from.").option("-A, --allow","Allow jsrepo to download code from the provided repo.",false).option("--cwd <path>","The current working directory.",process.cwd()).allowExcessArguments().allowUnknownOption().action(async(e,t,r)=>{let o=k.parse(cs,t);de(te),await ls(e,o,r);}),ls=async(e,t,r)=>{let o=e,n=spinner(),s=Ee(t.cwd),i=s.isErr(),a;s.isErr()?a={$schema:"",includeTests:false,watermark:true,paths:{"*":"./"},repos:[]}:a=s.unwrap();let l=a.repos;t.repo&&(l=[t.repo]);let f=o?q(o):undefined;if(o&&f){let{url:p}=f.parse(o,{fullyQualified:true});if(!l.find(b=>b===p)){if(!t.allow){let b=await confirm({message:`Allow ${fe} to download and run code from ${P.cyan(p)}?`,initialValue:true});(isCancel(b)||!b)&&(cancel("Canceled!"),process.exit(0));}l=[p];}}if(!t.allow&&t.repo){let p=await confirm({message:`Allow ${fe} to download and run code from ${P.cyan(t.repo)}?`,initialValue:true});(isCancel(p)||!p)&&(cancel("Canceled!"),process.exit(0));}l.length===0&&(i&&program.error(P.red(`Fully quality your script ex: (github/ieedan/std/scripts/build) or provide the \`${P.bold("--repo")}\` flag to specify a registry.`)),program.error(P.red(`There were no repos present in your config and you didn't provide the \`${P.bold("--repo")}\` flag with a repo.`))),n.start(`Fetching scripts from ${P.cyan(l.join(", "))}`);let m=(await qe(...l)).match(p=>p,({repo:p,message:b})=>{n.stop(`Failed to get info for ${P.cyan(p)}`),program.error(P.red(b));}),u=(await We(...m)).match(p=>p,({repo:p,message:b})=>{n.stop(`Failed fetching scripts from ${P.cyan(p)}`),program.error(P.red(b));});if(n.stop(`Retrieved scripts from ${P.cyan(l.join(", "))}`),!o){let p=await select({message:"Select which script to run.",options:Array.from(u.entries()).filter(([b,x])=>x.list).map(([b,x])=>{let A;return l.length>1?A=`${P.cyan(c(x.sourceRepo.url,x.category))}/${x.name}`:A=`${P.cyan(x.category)}/${x.name}`,{label:A,value:b}})});isCancel(p)&&(cancel("Canceled!"),process.exit(0)),o=p;}let d=(await Xe([o],u,m)).match(p=>p,p=>program.error(p)),c$1="temp-jsrepo-exec",$=`./${c$1}/${encodeURIComponent(o)}`,C=H.join(process.cwd(),$);a.paths["*"]=$,Oe.mkdirSync(C,{recursive:true});let y=(await detect({cwd:process.cwd()}))?.agent??"npm",w=[],h=new Set,L=new Set,J=De(a.paths,t.cwd);J.isErr()&&program.error(P.red(J.unwrapErr()));let U=J.unwrap(),g=[];for(let{block:p}of d){let b=`${p.sourceRepo.url}/${p.category}/${p.name}`,x=`${p.category}/${p.name}`,A=p.sourceRepo,K=H.join(t.cwd,U["*"],p.category);g.push(x),w.push({run:async({message:F})=>{F(`Adding ${P.cyan(b)}`),Oe.mkdirSync(K,{recursive:true});let O=[],ae=async M=>{let W=await Ke(A,M);return W.isErr()&&(n.stop(P.red(`Error fetching ${P.bold(M)}`)),program.error(P.red(`There was an error trying to get ${b}`))),W.unwrap()};for(let M of p.files){if(!a.includeTests&&Te(M))continue;let W=H.join(p.directory,M),q;p.subdirectory?q=H.join(K,p.name,M):q=H.join(K,M);let ce=await ae(W),ye=q.slice(0,q.length-M.length);Oe.mkdirSync(ye,{recursive:true}),O.push({content:ce,destPath:q});}for(let M of O)Oe.writeFileSync(M.destPath,M.content);if(a.includeTests&&p.tests){let{devDependencies:M}=JSON.parse(Oe.readFileSync(H.join(t.cwd,"package.json")).toString());(M===undefined||M.vitest===undefined)&&h.add("vitest");}for(let M of p.devDependencies)h.add(M);for(let M of p.dependencies)L.add(M);}});}if(await Gt({startMessage:"Adding blocks",stopMessage:`Added ${P.cyan(g.join(", "))}`,tasks:w}),L.size>0||h.size>0){let p={name:"temp-package",type:"module",version:"0.0.1"},b=H.join(C,"package.json");Oe.writeFileSync(b,JSON.stringify(p,null,"	")),L.size>0&&(t.verbose||n.start(`Installing dependencies with ${P.cyan(y)}`),(await je({pm:y,deps:Array.from(L),dev:false,cwd:C,ignoreWorkspace:true})).match(x=>{t.verbose||n.stop(`Installed ${P.cyan(x.join(", "))}`);},x=>{t.verbose||n.stop("Failed to install dependencies"),program.error(x);})),h.size>0&&(t.verbose||n.start(`Installing dependencies with ${P.cyan(y)}`),(await je({pm:y,deps:Array.from(h),dev:true,cwd:C,ignoreWorkspace:true})).match(x=>{t.verbose||n.stop(`Installed ${P.cyan(x.join(", "))}`);},x=>{t.verbose||n.stop("Failed to install dev dependencies"),program.error(x);}));}let E=r.parent.rawArgs.findIndex(p=>p==="--"),j=[];E!==-1&&(j=r.parent.rawArgs.slice(E+1)),console.clear();let z=d[0],X;z.block.subdirectory?X=H.join(C,`${z.block.category}/${z.block.name}/index.js`):X=H.join(C,`${z.block.category}/${z.block.name}.js`);let v=resolveCommand(y,"execute",["tsx",X,...j]);v||program.error(P.red("Error resolving run command!"));try{await execa(v.command,v.args,{cwd:process.cwd(),stdin:process.stdin,stdout:process.stdout});}finally{Oe.rmSync(H.join(process.cwd(),c$1),{recursive:true,force:true});}};var ys=k.object({repos:k.optional(k.array(k.string())),watermark:k.boolean(),tests:k.optional(k.boolean()),formatter:k.optional(Yt),project:k.optional(k.boolean()),registry:k.optional(k.boolean()),script:k.string(),yes:k.boolean(),cwd:k.string()}),hr=new Command("init").description("Initializes your project with a configuration file.").argument("[registries...]","Registries to install the blocks from.",[]).option("--repos [repos...]","Repository to install the blocks from. (DEPRECATED)").option("--no-watermark","Will not add a watermark to each file upon adding it to your project.").option("--tests","Will include tests with the blocks.").addOption(new Option("--formatter <formatter>","What formatter to use when adding or updating blocks.").choices(["prettier","biome"])).option("-P, --project","Takes you through the steps to initialize a project.").option("-R, --registry","Takes you through the steps to initialize a registry.").option("--script <name>","The name of the build script. (For Registry setup)","build:registry").option("-y, --yes","Skip confirmation prompt.",false).option("--cwd <path>","The current working directory.",process.cwd()).action(async(e,t)=>{let r=k.parse(ys,t);if(de(te),r.registry!==undefined&&r.project!==undefined&&program.error(P.red(`You cannot provide both ${P.bold("--project")} and ${P.bold("--registry")} at the same time.`)),r.repos!==undefined&&log.warn(`The ${P.gray("`--repos`")} flag is deprecated! Instead supply registries as arguments. ${P.cyan(`\`jsrepo init ${r.repos.join(" ")}\``)}`),r.registry===undefined&&r.project===undefined&&e.length===0){let o=await select({message:"Initialize a project or registry?",options:[{value:"project",label:"project"},{value:"registry",label:"registry"}],initialValue:"project"});isCancel(o)&&(cancel("Canceled!"),process.exit(0)),r.project=o==="project";}r.project||e.length>0?await hs(e,r):await vs(r),outro(P.green("All done!"));}),hs=async(e,t)=>{let r=Ee(t.cwd),o=spinner(),n,s=await text({message:"Please enter a default path to install the blocks",validate(d){if(d.trim()==="")return "Please provide a value"},placeholder:"./src/blocks",initialValue:r.isOk()?r.unwrap().paths["*"]:undefined});isCancel(s)&&(cancel("Canceled!"),process.exit(0)),r.isOk()?n={...r.unwrap().paths,"*":s}:n={"*":s};let i=[...r.isOk()?r.unwrap().repos:[],...e,...t.repos??[]];if(i.length>0)for(let d of i){if(r.isOk()&&r.unwrap().repos.find(c=>c===d)){let c=await confirm({message:`Configure ${d}?`,initialValue:t.yes});if(isCancel(c)&&(cancel("Canceled!"),process.exit(0)),!c)continue}log.info(`Configuring ${P.cyan(d)}`),n=await vo(d,n);}for(;;){let d=await confirm({message:`Add ${i.length>0?"another":"a"} repo?`,initialValue:i.length===0});if(isCancel(d)&&(cancel("Canceled!"),process.exit(0)),!d)break;let c=await text({message:"Where should we download the blocks from?",placeholder:"github/ieedan/std",validate:$=>{if($.trim().length===0)return "Please provide a value";if(!q($))return `Invalid provider! Valid providers (${p.map(C=>C.name).join(", ")})`}});isCancel(c)&&(cancel("Canceled!"),process.exit(0)),n=await vo(c,n),i.push(c);}if(!t.formatter){let d=r.isErr()?"none":r.unwrap().formatter??"none";Oe.existsSync(H.join(t.cwd,".prettierrc"))&&(d="prettier"),Oe.existsSync(H.join(t.cwd,"biome.json"))&&(d="biome");let c=await select({message:"What formatter would you like to use?",options:["Prettier","Biome","None"].map($=>({value:$.toLowerCase(),label:$})),initialValue:d});isCancel(c)&&(cancel("Canceled!"),process.exit(0)),c!=="none"&&(t.formatter=c);}let a={$schema:`https://unpkg.com/jsrepo@${te.package.version}/schemas/project-config.json`,repos:i,includeTests:r.isOk()&&t.tests===undefined?r.unwrap().includeTests:t.tests??false,watermark:t.watermark,formatter:t.formatter,paths:n};o.start(`Writing config to \`${Qe}\``);let{prettierOptions:l,biomeOptions:f}=await pt({formatter:a.formatter,cwd:t.cwd}),m=H.join(t.cwd,Qe),u=await nr.format(JSON.stringify(a,null,"	"),{biomeOptions:f,prettierOptions:l,filePath:m,formatter:a.formatter});Oe.existsSync(t.cwd)||Oe.mkdirSync(t.cwd,{recursive:true}),Oe.writeFileSync(m,u),o.stop(`Wrote config to \`${Qe}\`.`);},vo=async(e,t)=>{let r=spinner(),o$1=he(),n=q(e);n||program.error(P.red(`Invalid provider! Valid providers (${p.map(u=>u.name).join(", ")})`));let s=`${n.name}-token`;if(!o$1.get(s)&&n.name!==o.name){let u=await confirm({message:"Would you like to add an auth token?",initialValue:false});if(isCancel(u)&&(cancel("Canceled!"),process.exit(0)),u){let d=await password({message:"Paste your token",validate(c){if(c.trim()==="")return "Please provide a value"}});isCancel(d)&&(cancel("Canceled!"),process.exit(0)),o$1.set(s,d);}}r.start(`Fetching categories from ${P.cyan(e)}`);let a=await kt(e);a.isErr()&&program.error(P.red(a.unwrapErr()));let l=await Zt(a.unwrap());r.stop(`Fetched categories from ${P.cyan(e)}`),l.isErr()&&program.error(P.red(l.unwrapErr()));let f=l.unwrap(),m=await multiselect({message:"Which category paths would you like to configure?",options:f.categories.map(u=>({label:u.name,value:u.name})),required:false});if(isCancel(m)&&(cancel("Canceled!"),process.exit(0)),m.length>0)for(let u of m){let d=t[u],c=await text({message:`Where should ${u} be added in your project?`,validate($){if($.trim()==="")return "Please provide a value"},placeholder:d||`./src/${u}`,defaultValue:d,initialValue:d});isCancel(c)&&(cancel("Canceled!"),process.exit(0)),t[u]=c;}return t},vs=async e=>{let t=spinner(),r=H.join(e.cwd,"package.json");Oe.existsSync(r)||program.error(P.red(`Couldn't find your ${P.bold("package.json")}!`));let o=Ot(e.cwd).match(y=>y,y=>program.error(P.red(y))),n=o===null;for(o||(o={$schema:"",dirs:[],doNotListBlocks:[],doNotListCategories:[],listBlocks:[],listCategories:[],excludeDeps:[],includeBlocks:[],includeCategories:[],excludeBlocks:[],excludeCategories:[],preview:false}),o.$schema=`https://unpkg.com/jsrepo@${te.package.version}/schemas/registry-config.json`;;){if(o.dirs.length>0){let w=await confirm({message:"Add another blocks directory?",initialValue:false});if(isCancel(w)&&(cancel("Canceled!"),process.exit(0)),!w)break}let y=await text({message:"Where are your blocks located?",placeholder:"./src",defaultValue:"./src",initialValue:"./src",validate:w=>{if(w.trim().length===0)return "Please provide a value!"}});isCancel(y)&&(cancel("Canceled!"),process.exit(0)),o.dirs.push(y);}let s=JSON.parse(Oe.readFileSync(r).toString());for(;!e.yes&&s.scripts&&s.scripts[e.script];){let y=await confirm({message:`The \`${P.cyan(e.script)}\` already exists overwrite?`,initialValue:false});if(isCancel(y)&&(cancel("Canceled!"),process.exit(0)),y)break;{let w=await text({message:"What would you like to call the script?",placeholder:"build:registry",validate:h=>{if(h.trim().length===0)return "Please provide a value!"}});isCancel(w)&&(cancel("Canceled!"),process.exit(0)),e.script=w;}}let i=s.devDependencies&&s.devDependencies.jsrepo!==undefined,a=e.yes||i;if(!e.yes&&!i){let y=await confirm({message:`Add ${fe} as a dev dependency?`,initialValue:true});isCancel(y)&&(cancel("Canceled!"),process.exit(0)),a=y;}let l=!n;if(!e.yes&&n){let y=await confirm({message:`Create a \`${P.cyan(Ge)}\` file?`,initialValue:true});isCancel(y)&&(cancel("Canceled!"),process.exit(0)),l=y;}let f=(await detect$1({cwd:"cwd"}))?.agent??"npm",m="";if(a)m+="jsrepo build";else {let y=resolveCommand$1(f,"execute",["jsrepo","build"]);y||program.error(P.red(`Error resolving execute command for ${f}`)),m+=`${y.command} ${y.args.join(" ")} `;}l||(m+=` --dirs ${o.dirs.join(" ")} `),s.scripts===undefined&&(s.scripts={}),s.scripts[e.script]=m;let u=[];u.push({loadingMessage:`Adding \`${P.cyan(e.script)}\` to scripts in package.json`,completedMessage:`Added \`${P.cyan(e.script)}\` to scripts in package.json`,run:async()=>{try{Oe.writeFileSync(r,JSON.stringify(s,null,"	"));}catch(y){program.error(P.red(`Error writing to \`${P.bold(r)}\`. Error: ${y}`));}}}),l&&u.push({loadingMessage:`Writing config to \`${P.cyan(Ge)}\``,completedMessage:`Wrote config to \`${P.cyan(Ge)}\``,run:async()=>{let y=H.join(e.cwd,Ge);try{Oe.writeFileSync(H.join(y),JSON.stringify(o,null,"	"));}catch(w){program.error(P.red(`Error writing to \`${P.bold(y)}\`. Error: ${w}`));}}}),await bt(u,{});let d=i;if(a&&!i){let y=e.yes;if(!e.yes){let w=await confirm({message:"Install dependencies?",initialValue:true});isCancel(w)&&(cancel("Canceled!"),process.exit(0)),y=w;}y&&(t.start(`Installing ${fe}`),(await je({pm:f,deps:["jsrepo"],dev:true,cwd:e.cwd})).match(()=>t.stop(`Installed ${fe}.`),h=>{t.stop(`Failed to install ${fe}.`),program.error(h);}),d=true);}let c=[];if(!d&&a){let y=resolveCommand$1(f,"add",["jsrepo","-D"]);c.push(`Install ${fe} as a dev dependency \`${P.cyan(`${y?.command} ${y?.args.join(" ")}`)}\``);}c.push(`Add categories to \`${P.cyan(o.dirs.join(", "))}\`.`);let $=resolveCommand$1(f,"run",[e.script]);c.push(`Run \`${P.cyan(`${$?.command} ${$?.args.join(" ")}`)}\` to build the registry.`),c=c.map((y,w)=>`${w+1}. ${y}`);let C=ft(c);process.stdout.write(C);};var Es=k.object({repo:k.optional(k.string()),allow:k.boolean(),debug:k.boolean(),verbose:k.boolean(),cwd:k.string()}),wr=new Command("test").description("Tests local blocks against most recent remote tests.").addArgument(new Argument("[blocks...]","The blocks you want to test.").default([])).option("--repo <repo>","Repository to download the blocks from.").option("-A, --allow","Allow jsrepo to download code from the provided repo.",false).option("--debug","Leaves the temp test file around for debugging upon failure.",false).option("--verbose","Include debug logs.",false).option("--cwd <path>","The current working directory.",process.cwd()).action(async(e,t)=>{let r=k.parse(Es,t);de(te),await Ds(e,r),outro(P.green("All done!"));}),Ds=async(e,t)=>{let r=h=>{t.verbose&&console.info(`${at} ${h}`);};r(`Attempting to test ${JSON.stringify(e)}`);let o=Ee(t.cwd).match(h=>h,h=>program.error(P.red(h))),n=spinner(),s=o.repos;if(t.repo&&(s=[t.repo]),!t.allow&&t.repo){let h=await confirm({message:`Allow ${P.cyan("jsrepo")} to download and run code from ${P.cyan(t.repo)}?`,initialValue:true});(isCancel(h)||!h)&&(cancel("Canceled!"),process.exit(0));}t.verbose||n.start(`Fetching blocks from ${P.cyan(s.join(", "))}`);let i=(await qe(...s)).match(h=>h,({repo:h,message:L})=>{n.stop(`Failed to get info for ${P.cyan(h)}`),program.error(P.red(L));});r(`Resolved ${P.cyan(s.join(", "))}`),r(`Fetching blocks from ${P.cyan(s.join(", "))}`);let a=(await We(...i)).match(h=>h,({repo:h,message:L})=>{n.stop(`Failed fetching blocks from ${P.cyan(h)}`),program.error(P.red(L));});r(`Retrieved blocks from ${P.cyan(s.join(", "))}`),t.verbose||n.stop(`Retrieved blocks from ${P.cyan(s.join(", "))}`);let l=H.resolve(H.join(t.cwd,`blocks-tests-temp-${Date.now()}`));r(`Trying to create the temp directory ${P.bold(l)}.`),Oe.mkdirSync(l,{recursive:true});let f=()=>{Oe.rmSync(l,{recursive:true,force:true});},m=Ze(a,o,t.cwd).map(h=>h.specifier),u=e;e.length===0&&(u=m),u.length===0&&(f(),program.error(P.red("There were no blocks found in your project!")));let d=[];for(let h of u){let L,J=q(h);if(J){let{url:U}=J.parse(h,{fullyQualified:true}),g=(await kt(U)).match(E=>E,E=>program.error(P.red(E))),R=(await We(g)).match(E=>E,E=>program.error(P.red(E)));for(let[E,j]of R)a.set(E,j);L=a.get(h);}else for(let U of s){let g=q(U);if(!g)continue;let{url:R,specifier:E}=g.parse(c(U,h),{fullyQualified:true}),j=a.get(c(R,E));if(j!==undefined){L=j;break}}L||program.error(P.red(`Invalid block! ${P.bold(h)} does not exist!`)),d.push({name:h,block:L});}let c$1=De(o.paths,t.cwd);c$1.isErr()&&program.error(P.red(c$1.unwrapErr()));let $=c$1.unwrap();for(let{block:h}of d){let L=h.sourceRepo,J=c(h.sourceRepo.url,h.category,h.name);if(t.verbose||n.start(`Setting up test file for ${P.cyan(J)}`),!h.tests){n.stop(`No tests found for ${P.cyan(J)}`);continue}let U=ze(h,$,t.cwd);U=H.relative(l,U);let g=async j=>{let z=await Ke(L,j);return z.isErr()&&(n.stop(P.red(`Error fetching ${P.bold(j)}`)),program.error(P.red(`There was an error trying to get ${J}`))),z.unwrap()};r(`Downloading and copying test files for ${J}`);let R=[];for(let j of h.files.filter(z=>Te(z))){let z=await g(H.join(h.directory,j)),X=H.join(l,j);Oe.writeFileSync(X,z),R.push(X);}let E=new Project;for(let j of R){r(`Opening test file ${j}`);let z=E.addSourceFileAtPath(j);for(let X of z.getImportDeclarations()){let v=X.getModuleSpecifierValue(),p;v.startsWith(".")&&(h.subdirectory?p=H.join(U,h.name,v):p=H.join(U,v)),p&&X.setModuleSpecifier(p.replaceAll(/\\/g,"/"));}}E.saveSync(),r(`Completed ${P.cyan.bold(J)} test file`),t.verbose||n.stop(`Completed setup for ${P.bold(J)}`);}r("Beginning testing");let C=await detect({cwd:t.cwd});C==null&&program.error(P.red("Could not detect package manager"));let y=resolveCommand(C.agent,"execute",["vitest","run",l]);y==null&&program.error(P.red(`Could not resolve add command for '${C.agent}'.`));let w=`${y.command} ${y.args.join(" ")}`;r(`Running ${P.cyan(w)} on ${P.cyan(t.cwd)}`);try{await execa(y.command,y.args,{cwd:t.cwd,stdin:process.stdin,stdout:process.stdout}),f();}catch(h){t.debug?console.info(`${P.bold("--debug")} flag provided. Skipping cleanup. Run '${P.bold(w)}' to retry tests.
`):f(),program.error(P.red(`Tests failed! Error ${h}`));}};var $r={"Claude 3.5 Sonnet":{updateFile:async({originalFile:e,newFile:t,loading:r,verbose:o})=>{let n=await kr("Anthropic");o||r.start("Asking Claude 3.5 Sonnet");let s=zt({originalFile:e,newFile:t});o?.(`Prompting Claude 3.5 Sonnet with:
${JSON.stringify(s,null,"	")}`);let i=await Ls({model:"claude-3-5-sonnet-latest",prompt:s,apiKey:n,maxTokens:(e.content.length+t.content.length)*2});return o||r.stop("Claude 3.5 Sonnet updated the file"),i?Kt(i):t.content}},"ChatGPT 4o":{updateFile:async({originalFile:e,newFile:t,loading:r,verbose:o})=>{let n=await kr("OpenAI");o||r.start("Asking ChatGPT 4o");let s=zt({originalFile:e,newFile:t});o?.(`Prompting ChatGPT 4o with:
${JSON.stringify(s,null,"	")}`);let i=await $o({model:"gpt-4o",prompt:s,apiKey:n,maxTokens:(e.content.length+t.content.length)*2});return o||r.stop("ChatGPT 4o updated the file"),i?Kt(i):t.content}},"ChatGPT 4o-mini":{updateFile:async({originalFile:e,newFile:t,loading:r,verbose:o})=>{let n=await kr("OpenAI");o||r.start("Asking ChatGPT 4o-mini");let s=zt({originalFile:e,newFile:t});o?.(`Prompting ChatGPT 4o with:
${JSON.stringify(s,null,"	")}`);let i=await $o({model:"gpt-4o-mini",prompt:s,apiKey:n,maxTokens:(e.content.length+t.content.length)*2});return o||r.stop("ChatGPT 4o-mini updated the file"),i?Kt(i):t.content}},Phi4:{updateFile:async({originalFile:e,newFile:t,loading:r,verbose:o})=>{o||r.start("Asking Phi4");let n=zt({originalFile:e,newFile:t});o?.(`Prompting Phi4 with:
${JSON.stringify(n,null,"	")}`);let s=await _s({model:"phi4",prompt:n});return o||r.stop("Phi4 updated the file"),s?Kt(s):t.content}}},$o=async({prompt:e,maxTokens:t,model:r,apiKey:o})=>{let i=(await new Bs({apiKey:o}).chat.completions.create({model:r,max_completion_tokens:t,messages:[{role:"system",content:e.system},{role:"user",content:e.message}]})).choices[0];return i.message.content===null?null:i.message.content},Ls=async({prompt:e,maxTokens:t,model:r,apiKey:o})=>{let i=(await new Os({apiKey:o}).messages.create({model:r,max_tokens:Math.min(t,8192),temperature:.5,system:e.system,messages:[{role:"user",content:[{type:"text",text:e.message}]}]})).content[0];return i.type!=="text"?null:i.text},_s=async({prompt:e,model:t})=>(await Fs.chat({model:t,messages:[{role:"system",content:e.system},{role:"user",content:e.message}]})).message.content,zt=({originalFile:e,newFile:t})=>({system:"You will respond only with the resulting code. DO NOT format the code with markdown, DO NOT put the code inside of triple quotes, only return the code as a raw string.",message:`Help me merge these two files. DO NOT make unnecessary changes. 
I expect the original code to maintain the same behavior as it currently has while including any added functionality from the new file.
This means stuff like defaults or configuration should normally stay intact unless the new behaviors in the new file depend on those defaults or configuration.
This is my current file ${e.path}:
\`\`\`
${e.content}
\`\`\`
	
This is the file that has changes I want to update with ${t.path}:
\`\`\`
${t.content}
\`\`\`
	`}),Kt=e=>{let t=e.trim();if(t.startsWith("```")&&(t=Q(t).slice(1).join(`
`).trim()),t.endsWith("```")){let r=Q(t);t=r.slice(0,r.length-1).join(`
`).trim();}return t},kr=async e=>{let t=`${e}-api-key`,r=he(),o=r.get(t,null);if(!o){let n=await password({message:`Paste your ${e} API key:`,validate(s){if(s.trim()==="")return "Please provide an API key"}});(isCancel(n)||!n)&&(cancel("Canceled!"),process.exit(0)),o=n;}return r.set(t,o),o};var bo=(e,t)=>{let r=0;for(let o of e)r=r+t(o);return r};var Co=e=>/^\s+$/g.test(e),ht=e=>{let t=e.length-1;for(;Co(e[t])&&t>=0;){if(e[t]===`
`)return e[t-1]==="\r"?e.slice(0,t-1):e.slice(0,t);t--;}return e},xo=({from:e,to:t,changes:r,expand:o=false,maxUnchanged:n=5,colorRemoved:s=P.redBright,colorAdded:i=P.greenBright,colorCharsRemoved:a=P.bgRedBright,colorCharsAdded:l=P.bgGreenBright,prefix:f,onUnchanged:m,intro:u})=>{let d="",c=bo(r,y=>y.count??0).toString().length+1,$=0;if(r.length===1&&!r[0].added&&!r[0].removed)return m({from:e,to:t,changes:r,expand:o,maxUnchanged:n,colorAdded:i,colorRemoved:s,prefix:f,onUnchanged:m,intro:u});d+=u({from:e,to:t,changes:r,expand:o,maxUnchanged:n,colorAdded:i,colorRemoved:s,prefix:f,onUnchanged:m,intro:u});let C=y=>P.gray(`${f?.()??""}${$t(`${y+1+$} `,c)} `);for(let y=0;y<r.length;y++){let w=r[y],h=r[y-1]?.added||r[y-1]?.removed,L=r[y+1]?.added||r[y+1]?.removed;if(!w.added&&!w.removed){if(!o&&w.count!==undefined&&w.count>n){let g=$,R=Q(ht(w.value)),E=0;if(L&&(E+=n),h&&(E+=n),E>=R.length){d+=`${Z(R,{prefix:C})}
`,$+=R.length;continue}if(h&&(d+=`${Z(R.slice(0,n),{prefix:C})}
`),R.length>E){let j=R.length-E;d+=`${Z(Q(P.gray(`+ ${j} more unchanged (${P.italic("-E to expand")})`)),{prefix:()=>`${f?.()??""}${$t(" ",c)} `})}
`;}L&&($=$+R.length-n,d+=`${Z(R.slice(R.length-n),{prefix:C})}
`),$=g+w.count;continue}d+=`${Z(Q(ht(w.value)),{prefix:C})}
`,$+=w.count??0;continue}let J=g=>g.added?i(ht(g.value)):g.removed?s(ht(g.value)):g.value,U=g=>g.added?l(ht(g.value)):g.removed?a(ht(g.value)):g.value;if(w.removed&&w.count===1&&r[y+1]?.added&&r[y+1]?.count===1){let R=diffChars(w.value,r[y+1].value).map(E=>U(E)).join("");d+=`${C(0)}${R}`,$+=1,y++;}else Co(w.value)?(d+=`${Z(Q(U(w)),{prefix:g=>`${C(g)}${U({removed:true,value:"   ",added:false})}`})}
`,w.removed||($+=w.count??0)):(d+=`${Z(Q(J(w)),{prefix:C})}
`,w.removed||($+=w.count??0));}return d};var Us=k.object({all:k.boolean(),expand:k.boolean(),maxUnchanged:k.number(),no:k.boolean(),repo:k.optional(k.string()),allow:k.boolean(),yes:k.boolean(),verbose:k.boolean(),cwd:k.string()}),br=new Command("update").description("Update blocks to the code in the remote repository.").argument("[blocks...]","Names of the blocks you want to update. ex: (utils/math)").option("--all","Update all installed components.",false).option("-E, --expand","Expands the diff so you see everything.",false).option("--max-unchanged <number>","Maximum unchanged lines that will show without being collapsed.",e=>Number.parseInt(e),3).option("-n, --no","Do update any blocks.",false).option("--repo <repo>","Repository to download the blocks from.").option("-A, --allow","Allow jsrepo to download code from the provided repo.",false).option("-y, --yes","Skip confirmation prompt.",false).option("--verbose","Include debug logs.",false).option("--cwd <path>","The current working directory.",process.cwd()).action(async(e,t)=>{let r=k.parse(Us,t);de(te),await Hs(e,r),outro(P.green("All done!"));}),Hs=async(e,t)=>{let r=g=>{t.verbose&&console.info(`${at} ${g}`);};r(`Attempting to update ${JSON.stringify(e)}`);let o=spinner(),n=Ee(t.cwd).match(g=>g,g=>program.error(P.red(g))),s=n.repos;t.repo&&(s=[t.repo]);for(let g of e)p.find(R=>g.startsWith(R.name))&&program.error(P.red(`Invalid value provided for block names \`${P.bold(g)}\`. Block names are expected to be provided in the format of \`${P.bold("<category>/<name>")}\``));if(!t.allow&&t.repo){let g=await confirm({message:`Allow ${P.cyan("jsrepo")} to download and run code from ${P.cyan(t.repo)}?`,initialValue:true});(isCancel(g)||!g)&&(cancel("Canceled!"),process.exit(0));}r(`Resolving ${P.cyan(s.join(", "))}`),t.verbose||o.start(`Fetching blocks from ${P.cyan(s.join(", "))}`);let i=(await qe(...s)).match(g=>g,({repo:g,message:R})=>{o.stop(`Failed to get info for ${P.cyan(g)}`),program.error(P.red(R));});r(`Resolved ${P.cyan(s.join(", "))}`),r(`Fetching blocks from ${P.cyan(s.join(", "))}`);let a=(await We(...i)).match(g=>g,({repo:g,message:R})=>{o.stop(`Failed fetching blocks from ${P.cyan(g)}`),program.error(P.red(R));});t.verbose||o.stop(`Retrieved blocks from ${P.cyan(s.join(", "))}`),r(`Retrieved blocks from ${P.cyan(s.join(", "))}`);let l=Ze(a,n,t.cwd);l.length===0&&program.error(P.red(`You haven't installed any blocks yet. Did you mean to \`${P.bold("add")}\`?`));let f=e;if(t.all&&(f=l.map(g=>g.specifier)),f.length===0){let g=await multiselect({message:`Which blocks would you like to ${t.no?"diff":"update"}?`,options:l.filter(R=>R.block.list).map(R=>({label:`${P.cyan(R.block.category)}/${R.block.name}`,value:R.specifier})),required:true});isCancel(g)&&(cancel("Canceled!"),process.exit(0)),f=g;}r(`Preparing to update ${P.cyan(f.join(", "))}`);let m=(await Xe(f,a,i)).match(g=>g,program.error),u=(await detect({cwd:t.cwd}))?.agent??"npm",d=[],c$1=new Set,$=new Set,{prettierOptions:C,biomeOptions:y}=await pt({formatter:n.formatter,cwd:t.cwd}),w=De(n.paths,t.cwd);w.isErr()&&program.error(P.red(w.unwrapErr()));let h=w.unwrap(),L="Claude 3.5 Sonnet";for(let{block:g}of m){let R=c(g.sourceRepo.url,g.category,g.name),E=Jt(te.package.version,g.sourceRepo.url),j=g.sourceRepo;r(`Attempting to add ${R}`);let z=ze(g,h,t.cwd),X=[],v=async p=>{let b=await Ke(j,p,{verbose:r});return b.isErr()&&(o.stop(P.red(`Error fetching ${P.bold(p)}`)),program.error(P.red(`There was an error trying to get ${R}`))),b.unwrap()};for(let p of g.files){if(!n.includeTests&&Te(p))continue;let b=H.join(g.directory,p),x;g.subdirectory?x=H.join(z,g.name,p):x=H.join(z,p);let A=await v(b);Oe.mkdirSync(x.slice(0,x.length-p.length),{recursive:true}),X.push({content:A,destPath:x,fileName:p});}process.stdout.write(`${B}
`),process.stdout.write(`${B}  ${R}
`);for(let p of X){let b=await Vt({file:p,biomeOptions:y,prettierOptions:C,config:n,imports:g._imports_,watermark:E,verbose:r,cwd:t.cwd});b.isErr()&&program.error(P.red(b.unwrapErr()));let x=b.unwrap(),A=b.unwrap(),K=t.yes;if(!t.yes){process.stdout.write(`${B}
`);let F="";Oe.existsSync(p.destPath)&&(F=Oe.readFileSync(p.destPath).toString());let O=c(j.url,p.fileName),ae=H.relative(t.cwd,p.destPath);for(;;){let M=diffLines(F,A),W=xo({from:O,to:ae,changes:M,expand:t.expand,maxUnchanged:t.maxUnchanged,prefix:()=>`${B}  `,onUnchanged:({from:q,to:ce,prefix:ye})=>`${ye?.()??""}${P.cyan(q)} \u2192 ${P.gray(ce)} ${P.gray("(unchanged)")}
`,intro:({from:q,to:ce,changes:ye,prefix:it})=>{let xr=ye.filter(Rr=>Rr.added||Rr.removed).length;return `${it?.()??""}${P.cyan(q)} \u2192 ${P.gray(ce)} (${xr} change${xr===1?"":"s"})
${it?.()??""}
`}});if(process.stdout.write(W),(M.length>1||F==="")&&(K=t.yes,!t.yes&&!t.no)){let q=await select({message:"Accept changes?",options:[{label:"Accept",value:"accept"},{label:"Reject",value:"reject"},{label:`\u2728 ${P.yellow("Update with AI")} \u2728`,value:"update"}]});if(isCancel(q)&&(cancel("Canceled!"),process.exit(0)),q==="update"){let ce=await select({message:"Select a model",options:Object.keys($r).map(ye=>({label:ye,value:ye}))});isCancel(ce)&&(cancel("Canceled!"),process.exit(0)),L=ce;try{A=await $r[L].updateFile({originalFile:{content:F,path:ae},newFile:{content:x,path:O},loading:o,verbose:t.verbose?r:void 0});}catch(ye){o.stop(),log.error(P.red(`Error getting completions: ${ye}`)),process.stdout.write(`${B}
`);continue}A=await so({file:{content:A,destPath:p.destPath},biomeOptions:y,prettierOptions:C,config:n}),process.stdout.write(`${B}
`);continue}K=q==="accept";break}break}}K&&await bt([{loadingMessage:`Writing changes to ${P.cyan(p.destPath)}`,completedMessage:`Wrote changes to ${P.cyan(p.destPath)}.`,run:async()=>Oe.writeFileSync(p.destPath,A)}],{verbose:t.verbose?r:undefined});}if(n.includeTests&&g.tests){r("Trying to include tests");let{devDependencies:p}=JSON.parse(Oe.readFileSync(H.join(t.cwd,"package.json")).toString());(p===undefined||p.vitest===undefined)&&c$1.add("vitest");}for(let p of g.devDependencies)c$1.add(p);for(let p of g.dependencies)$.add(p);}await bt(d,{verbose:t.verbose?r:undefined});let J=Tt($,c$1,{cwd:t.cwd});if($=J.dependencies,c$1=J.devDependencies,$.size>0||c$1.size>0){let g=t.yes;if(!t.yes&&!t.no){let j=await confirm({message:"Would you like to install dependencies?",initialValue:true});isCancel(j)&&(cancel("Canceled!"),process.exit(0)),g=j;}g&&($.size>0&&(t.verbose||o.start(`Installing dependencies with ${P.cyan(u)}`),(await je({pm:u,deps:Array.from($),dev:false,cwd:t.cwd})).match(j=>{t.verbose||o.stop(`Installed ${P.cyan(j.join(", "))}`);},j=>{t.verbose||o.stop("Failed to install dependencies"),program.error(j);})),c$1.size>0&&(t.verbose||o.start(`Installing dependencies with ${P.cyan(u)}`),(await je({pm:u,deps:Array.from(c$1),dev:true,cwd:t.cwd})).match(j=>{t.verbose||o.stop(`Installed ${P.cyan(j.join(", "))}`);},j=>{t.verbose||o.stop("Failed to install dev dependencies"),program.error(j);})));let R=[];if(!g){if($.size>0){let j=resolveCommand(u,"add",[...$]);R.push(`Install dependencies \`${P.cyan(`${j?.command} ${j?.args.join(" ")}`)}\``);}if(c$1.size>0){let j=resolveCommand(u,"add",[...c$1,"-D"]);R.push(`Install dev dependencies \`${P.cyan(`${j?.command} ${j?.args.join(" ")}`)}\``);}}R=R.map((j,z)=>`${z+1}. ${j}`),g||R.push(""),R.push("Import and use the blocks!");let E=ft(R);process.stdout.write(E);}};var Cr="latest-version",Xs=60*60*1e3,Po=async()=>{try{let e=he(),t,r=e.get(Cr);if(r){if(r.expiration>Date.now())return t=r.version,a(t);e.delete(Cr);}let o=new AbortController,n=setTimeout(()=>{o.abort();},1e3),s=await Xt("https://raw.githubusercontent.com/ieedan/jsrepo/refs/heads/main/packages/cli/package.json",{signal:o.signal});if(clearTimeout(n),!s.ok)return b("Error getting version");let{version:i}=await s.json();return t=i,e.set(Cr,{expiration:Date.now()+Xs,version:t}),a(t)}catch(e){return b(`Error getting version: ${e}`)}};var Io=e=>{let t=fileURLToPath(import.meta.url);return H.join(t,"../..",e)},{version:Eo,name:Do,description:Oo,repository:oi}=JSON.parse(Oe.readFileSync(Io("package.json"),"utf-8")),ni=(await Po()).match(e=>e,()=>{}),te={package:{name:Do,description:Oo,version:Eo,repository:oi,latestVersion:ni},resolveRelativeToRoot:Io},No=program.name(Do).description(Oo).version(Eo).addCommand(ar).addCommand(dr).addCommand(pr).addCommand(ur).addCommand(hr).addCommand(wr).addCommand(br);No.parse();//# sourceMappingURL=index.js.map
//# sourceMappingURL=index.js.map